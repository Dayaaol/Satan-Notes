Fuzzing:
=======
Basics:
	The process of sending random data of varying length as input is known as "fuzzing".
		Input can be passed via:
			Cli args
			Parameters
			Network data
			Database
			Enviroment variables
			Passing a File as input
	This helps to find aprox number of bytes to crash the application.
	Classification of fuzzers:
Creating fuzzing scripts:
	Using Python:
		Note:
			To read more about sys/socket/os libraries of python2/3, read Python Scripting sheet
		Step-1: Creating a mainframe:
			This is literally the first step to find a 0-day
			We will Fuzz every input field hoping to crash the application.
				For WebApps:
					using BURP to see data:
				For any Application:
					using WireShark to see data packets:
							Select Data-Packet -> Right-click -> follow -> TCP-Stream
					https://blog.badatsecurity.net/2018/03/upcoming-post-how-to-not-be-quite-as.html
		Step-2:
			Example Script:(https://github.com/Tib3rius/Pentest-Cheatsheets/blob/master/exploits/buffer-overflows.rst)
				#!/usr/bin/python
				import socket, time, sys
				ip = "10.0.0.1"
				port = 21
				timeout = 5
				buffer = []
				counter = 100
				while len(buffer) < 30:
				    buffer.append("A" * counter)
				    counter += 100
				for string in buffer:
				    try:
				        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
				        s.settimeout(timeout)
				        connect = s.connect((ip, port))
				        s.recv(1024)
				        s.send("USER username\r\n")
				        s.recv(1024)
				        print("Fuzzing PASS with %s bytes" % len(string))
				        s.send("PASS " + string + "\r\n")
				        s.recv(1024)
				        s.send("QUIT\r\n")
				        s.recv(1024)
				        s.close()
				    except:
				        print("Could not connect to " + ip + ":" + str(port))
				        sys.exit(0)
				    time.sleep(1)
Note:
	Sometimes, fuzzers dont stop sending buffer. So, always keep an eye on "Assembly Instructions" Window. As soon as it goes blank, stop the fuuzzer and note the buffer size sent.
	This mostly happens in BOF over HTTP
Note:
	Sometimes, registers window goes blank during fuzzing, so press "ALT + C"
Note:(Spiking)
	Spike is a fuzzer which is very adaptable. Spike is an API that enables the hacker/security researcher to quickly develop protocol stress tests
	generic_send_tcp:
		Pre-Installed in Kali
		Usage:
			generic_send_tcp host port script.spk SKIPVAR SKIPSTR
			generic_send_tcp 172.16.42.131 9999 script.spk 0 0
				script.spk:(Spike Script)
					/usr/share/spike/audits => In-built spike scripts in Kali
					example:
						s_readline();
						s_string("Input_field_to_spike ");
						s_string_variable("0");
			Note:
				We use "0" for SKIPVAR and SKIPSTR when we are unsure
		Issues:
			Spiking is good when we wanna discover a vulnerability as its fast and crashes the application easily. However, its difficult to find offset using spiking as a fuzzer.



Fuzzer in Python3:(Not OSCP)
	Python3 General Fuzzer Script:(Lets do it once OSCP is done)
		Differences between python2 and python3:
			print:
				python2 => print "hello world"
				python3 => print("hello world")
			socket:
				socket.send() and socket.recv() deal with bytes in python3 and with strings in python2
				python2 => s.send(buf), s.recv(1024)
				python3:
					buf = b"" # we need to convert our buffer to bytes
					buf += b"---------------"
					buf += b"\n"
					s.send(buf)
					data = s.recv(buf)
					print(format(data))
		Found python3 scripts on github:
			https://github.com/fnginfosec/Buffer-Overflow-Scripts
		https://stackoverflow.com/questions/57585284/using-python-3-as-a-buffer-overflow-instead-of-python-2	

Note:
	Fuzzing is not required for the OSCP exam, so it is not covered in this post.
	We will be provided with a fuzzer script in OSCP exam along with length of "A"s to crash the application